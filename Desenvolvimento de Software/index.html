<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Desenvolvimento de Software</title>
    <link rel="stylesheet" href="../headermenufooter.css">
    <link rel="stylesheet" href="../estiloMaterias.css">
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code&display=swap" rel="stylesheet">
</head>
<body>
    <header>
        <h1>Desenvolvimento de Software</h1>
    </header>
    <div class="menu-hamburguer" onclick="toggleMenu()">
        <div></div>
        <div></div>
        <div></div>
    </div>
    <nav class="menu" id="menu">
        <ul>
            <li><a href="../index.html">Início</a></li>
            <li><a href="../Banco de Dados/index.html">Banco de Dados</a></li>
            <li><a href="../Conhecimentos Bancários/index.html">Conhecimentos Bancários</a></li>
            <li><a href="../Desenvolvimento de Software/index.html">Desenvolvimento de Software</a></li>
            <li><a href="../Probabilidade e Estatística/index.html">Probabilidade e Estatística</a></li>
            <li><a href="../Inglês/index.html">Inglês</a></li>
            <li><a href="../Português/index.html">Português</a></li>
            <li><a href="../Matemática/index.html">Matemática</a></li>
            <li><a href="../Simulado/index.html">Simulado</a></li>
            <li><a href="../Redação/index.html">Redação</a></li>
        </ul>
    </nav>
    <main>
        <section>

            <!-- AULA 00-->
    
            <h2>Aula 00 - Lógica de Programação</h2>
            <h3>Programação</h3>
            <p>Com a programação, podemos criar diversos tipos de aplicativos:</p>
            <ul>
                <li>Aplicativos web (sites interativos)</li>
                <li>Aplicativos de gestão empresarial (ERP)</li>
                <li>Jogos</li>
                <li>Entre muitos outros</li>
            </ul>
            <p>Um computador, por natureza, é “burro e preguiçoso”: ele não sabe o que fazer, e só irá fazer algo a pedido de um terceiro, nunca pela sua própria vontade. <strong><em>A programação computacional vista justamente dizer ao computador o que fazer.</em></strong></p>
            <p>Essas orientações ao computador são escritas a partir de algoritmos.</p>
            <h3>Algoritmo</h3>
            <p>Um algoritmo é uma sequência finita de instruções bem definidas e não ambíguas que descrevem um processo ou conjunto de operações a serem executadas para resolver um problema específico. Essa instruções são lidas e interpretadas em uma ordem específica, usualmente na ordem em que são escritas no código.</p>
            <p class="destaqueVermelho">Algoritmos são instruções que visam dar uma solução a um problema</p>
            <p>Saindo do mundo computacional, imagine que você tem uma decisão a tomar - pense que sua namorada (o) está exigindo veementemente que você a leve ao cinema. Diante desse cenário, você concorda e decide ir ao cinema. O objetivo final é assistir ao filme, então você faz uma sequência de passos:</p>
            <ol>
                <li>Veste uma roupa cheirosa e limpa</li>
                <li>Passa para pegar sua companhia</li>
                <li>Escolhe uma sessão</li>
                <li>Compra os ingressos para o filme</li>
                <li>Assiste ao filme</li>
            </ol>
            <p>Então, um algoritmo para a situação narrada acima pode ser:</p>
            <div class="tabelaEditorCodigo">
                <table>
                    <thead>
                        <tr class="cabecalhoEditorCodigo">
                            <td class="linhaEditorCodigo">Pseudocódigo</td>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td style="padding: 10px 0px 0px 30px;">Início</td>
                        </tr>
                        <tr>
                            <td style="padding: 10px 0px 0px 60px;"><span class="verdecodigo">preparação</span>( ) {</td>
                        </tr>
                        <tr>
                            <td style="padding: 10px 0px 0px 90px;">colocar a roupa,</td>
                        </tr>
                        <tr>
                            <td style="padding: 10px 0px 0px 90px;">pegar a companhia,</td>
                        </tr>
                        <tr>
                            <td style="padding: 10px 0px 0px 90px;">ir ao cinema</td>
                        </tr>
                        <tr>
                            <td style="padding: 10px 0px 0px 60px;">}</td>
                        </tr>
                        <tr>
                            <td style="padding: 10px 0px 0px 60px;"></td>
                        </tr>
                        <tr>
                            <td style="padding: 10px 0px 0px 60px;"><span class="verdecodigo">filme</span>( ) {</td>
                        </tr>
                        <tr>
                            <td style="padding: 10px 0px 0px 90px;">escolher sessão,</td>
                        </tr>
                        <tr>
                            <td style="padding: 10px 0px 0px 90px;">comprar ingresso,</td>
                        </tr>
                        <tr>
                            <td style="padding: 10px 0px 0px 90px;">assistir ao filme</td>
                        </tr>
                        <tr>
                            <td style="padding: 10px 0px 0px 60px;">}</td>
                        </tr>
                        <tr>
                            <td style="padding: 10px 0px 10px 30px;">Fim</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <p>E pronto, você cumpriu o seu objetivo - que era assistir ao filme no cinema. Porém, no meio desse caminho podem existir situações que impedem a consecução do objetivo, como o fato do filme não estar mais em exibição, ou estar com uma sessão lotada. Na computação, a programação visa, através dos algoritmos, justamente dar instruções gerais e alternativas, para lidar com os percalços, visando chegar num objetivo aceitável.</p>
            <h3>Linguagens de Programação</h3>
            <p>Uma linguagem de programação é um conjunto de regras, símbolos e convenções que permitem que programadores escrevam instruções que um computador pode entender e executar. Essas instruções, chamadas de código-fonte, são escritas em um formato compreensível para humanos, mas devem ser traduzidas para uma forma que o computador possa entender e executar, geralmente na forma de código de máquina.</p>
            <p>Podemos dividir as linguagens de programação conforme alguns grupos distintos, dependendo doque estamos analisando. Por exemplo, podemos classificar:</p>
            <ul>
                <li><strong>Nível de Abstração:</strong>
                    <ul>
                        <li style="padding: 5px;"><strong>Linguagens de baixo nível:</strong> São mais próximas da linguagem de máquina e fornecem um controle direto sobre o hardware do computador. Exemplos incluem Assembly.</li>
                        <li style="padding: 5px;"><strong>Linguagens de alto nível:</strong> São mais abstratas e fornecem construções mais poderosas e expressivas. Exemplos incluem Python, Java, C++.</li>
                    </ul>
                </li>
                <li><strong>Paradigma de Programação:</strong>
                    <ul>
                        <li style="padding: 5px;"><strong>Imperativa:</strong> As instruções são executadas sequencialmente, alterando o estado do programa através de atribuições. Exemplos incluem C, Fortran.</li>
                        <li style="padding: 5px;"><strong>Orientada a Objetos:</strong> Os programas são organizados em torno de objetos que podem conter dados e métodos. Exemplos incluem Java, C++.</li>
                        <li style="padding: 5px;"><strong>Funcional:</strong> Os programas são construídos com funções puras que evitam efeitos colaterais. Exemplos incluem Haskell, Lisp.</li>
                        <li style="padding: 5px;"><strong>Lógica:</strong> Os programas são construídos em torno de regras lógicas e inferências.Exemplos incluem Prolog.</li>
                    </ul>
                </li>
                <li><strong>Propósito:</strong>
                    <ul>
                        <li style="padding: 5px;"><strong>Geral:</strong> São usadas para uma ampla variedade de aplicações. Exemplos incluem Python, C++.</li>
                        <li style="padding: 5px;"><strong>Específica de Domínio:</strong> São otimizadas para resolver problemas em um domínio específico. Exemplos incluem SQL para bancos de dados, MATLAB para computação numérica.</li>
                    </ul>
                </li>
                <li><strong>Compilação:</strong>
                    <ul>
                        <li style="padding: 5px;"><strong>Compiladas:</strong> São traduzidas integralmente para código de máquina antes da execução. Exemplos incluem C, C++.</li>
                        <li style="padding: 5px;"><strong>Interpretadas:</strong> São executadas linha por linha por um interpretador. Exemplos incluem Python, JavaScript.</li>
                    </ul>
                </li>
            </ul>
            <h3>Variáveis e Constantes</h3>
            <p><strong>Conceitos gerais</strong></p>
            <p>Quando estamos programando, pode ser necessário armazenar algum tipo de valor, de dado, no conjunto de instruções que estamos passando ao computador.</p>
            <p>A programação tem um tipo de estrutura específica para lidar com isso: são as variáveis. As variáveis representam locais de armazenamento na memória do computador onde valores podem ser guardados e manipulados durante a execução de um programa. Cada variável possui um nome único que a identifica e um tipo de dado que determina o tipo de informação que pode ser armazenada nela.</p>
            <p>Uma variável é composta de três partes distintas:</p>
            <ul>
                <li>Identificador (ou nome)</li>
                <li>Tipo de dado</li>
                <li>Valor</li>
            </ul>
            <div class="tabelaExplica">
                <table>
                    <tbody>
                        <tr>
                            <th colspan="3">Variáveis</td>
                        </tr>
                        <tr>
                            <th>Tipo de dado</th>
                            <th>Identificador</th>
                            <th>Valor</th>
                        </tr>
                        <tr>
                            <td>int</td>
                            <td>idade</td>
                            <td>31</td>
                        </tr>
                        <tr>
                            <td>string</td>
                            <td>frase</td>
                            <td>parabéns pela aprovação!</td>
                        </tr>
                        <tr>
                            <td>float</td>
                            <td>nota</td>
                            <td>5.5</td>
                        </tr>
                        <tr>
                            <td>boolean</td>
                            <td>resposta</td>
                            <td>verdadeiro</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <p>O <strong>identificador</strong> será responsável por, justamente, <strong>identificar</strong> uma variável de <strong>forma inequívoca</strong>. É, basicamente, <strong>o nome da variável</strong>. Então, por exemplo, podemos criar uma variável “Fome”, que irá comportar o valor sobre o estado de fome atual, ou a variável “Cor_Cabelo”, que irá receber valores para cor de cabelo.</p>
            <p>O <strong>tipo de dado</strong> refere-se ao formato do valor que será alocado à variável. Cada linguagem específica trabalha com tipos de dados diferentes, mas, de forma geral, podemos definir alguns tipos de dados básicos - e que usaremos hoje:</p>
            <ul>
                <li><strong><u>Caracteres</u> - string</strong> > um conjunto de caracteres alfanuméricos. Exemplo: "Você será aprovado, Coruja!"</li>
                <li><strong><u>Números inteiros</u> - int</strong> > números do tipo inteiro. Exemplo: 4, 9, 13, 293</li>
                <li><strong><u>Números decimais</u> - double ou float</strong> > números de precisão decimal. Exemplo: 4.91</li>
                <li><strong><u>Lógico</u> - boolean</strong> > valores lógicos. Exemplo: Verdadeiro, Falso.</li>
            </ul>
            <p>Então, uma variável do tipo string comportará um conjunto de caracteres, usualmente formando algum tipo de texto. Especificamente nesse caso, as strings são delimitadas pelo uso de aspas - podendo ser aspas simples <span class="destaqueCinza">´string´</span> ou aspas duplas <span class="destaqueCinza">“string”</span>. Isso é um ponto muito importante, e cobrado muito pelas bancas, veja os seguintes valores:</p>
            <ul>
                <li>5</li>
                <li>“5”</li>
            </ul>
            <p>Se formos fazer uma comparação restrita, isso é, verificando tanto o valor quanto o tipo do dado anotado, veremos que os dois valores são diferentes. Portanto, 5 ≠ “5”. Isso, pois a notação 5 indica que estamos trabalhando com um tipo numérico inteiro, e a notação “5” com uma string de caracteres.</p>
            <p>Outro ponto que é importante destacar sobre os tipos de dado é a <strong>tipagem</strong>. A tipagem diz respeita à forma como as linguagens lidam com as definições de tipos de dado. Cada linguagem de programação pode ter propriedades diferentes quanto <strong>à força da tipagem</strong> e quanto à <strong>dinamicidade da tipagem</strong>. A <strong>força da tipagem</strong> diz respeito à <strong>rigidez ou flexibilidade</strong> de uma linguagem com relação aos <strong>tipos de dados de uma variável</strong>.</p>
            <p>No aspecto de força, uma linguagem pode ser:</p>
            <ul>
                <li><strong>Fortemente tipada:</strong> o escopo do tipo de dado não é flexível, não permitindo, portanto, operações entre tipos de dados distintos - assim, é exigida uma transformação explícita dos dados ao mesmo tipo antes de operações, caso contrário a operação apontará erros. Exemplo de linguagens fortemente tipadas incluem Python e Java.</li>
                <li><strong>Fracamente tipada:</strong> temos um escopo flexível para cada variável, permitindo operações entre diferentes tipos sem a necessidade de uma transformação de tipo de dado explícita, já que a linguagem irá fazer a conversão implicitamente. Exemplos de linguagem incluem JavaScript e PHP.</li>
            </ul>
            <p>Já a <strong>dinamicidade</strong> da tipagem diz respeito sobre a capacidade de uma linguagem determinar o tipo de variável durante a execução de um programa. Uma linguagem pode ser também de dois tipos, quanto à dinamicidade:</p>
            <ul>
                <li><strong>Tipagem dinâmica:</strong> o tipo é definido com base no valor que está sendo atribuído, sem necessidade de indicação expressa do tipo de dado. Exemplo: JavaScript e Python.</li>
                <li><strong>Tipagem estática:</strong> a linguagem é incapaz de definir, por ela mesma, o tipo de dado apenas com base no valor - nesse caso, é necessária uma declaração explícita do tipo de dado junto da variável. Exemplo: Java, C++.</li>
            </ul>
            <div class="tabelaExplica">
                <table>
                    <tbody>
                        <tr>
                            <th colspan="4">Propriedades do Tipo</th>
                        </tr>
                        <tr>
                            <th colspan="2">Força</th>
                            <th colspan="2">Dinamicidade</th>
                        </tr>
                        <tr>
                            <th>Tipagem fraca</th>
                            <th>Tipagem forte</th>
                            <th>Tipagem dinâmica</th>
                            <th>Tipagem estática</th>
                        </tr>
                    </tbody>
                </table>
            </div>
            <p>E, por fim, temos o <strong>valor</strong> da variável. É nele que declaramos o que a variável comportará, seu conteúdo. Esse valor, por estarmos tratando de uma variável, é, justamente, variável. Ele poderá ser modificado ao longo da execução de um código sem nenhum problema maior. Em contraponto a isso, temos as <strong>constantes</strong>. Valores armazenados em uma constante não podem ser alterados depois de declarados e atribuídos.</p>
            <p class="destaqueVermelho">Variável > Valor pode ser alterado<br>Constante > Valor não pode ser alterado</p>
            <h3>Declarando variáveis</h3>
            <p>Agora que você sabe o que é uma variável, precisamos aprender a declará-la. Já fizemos isso lá em cima, quando dei o exemplo de uma variável idade a vocês. Cada linguagem tem uma forma diferente, veja como funciona em diferentes linguagens:</p>
            <div class="tabelaEditorCodigo">
                <table>
                    <tbody>
                        <tr class="cabecalhoEditorCodigo">
                            <td class="linhaEditorCodigo">JavaScript</td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="azulcodigo"><em>let</em></span> melhorCurso <span class="rosacodigo">=</span> <span class="amarelocodigo">"Estratégia"</span></td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="tabelaEditorCodigo">
                <table>
                    <tbody>
                        <tr class="cabecalhoEditorCodigo">
                            <td class="linhaEditorCodigo">Python</td>
                        </tr>
                        <tr>
                            <td class="umtab">melhorCurso <span class="rosacodigo">=</span> <span class="amarelocodigo">"Estratégia"</span></td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="tabelaEditorCodigo">
                <table>
                    <tbody>
                        <tr class="cabecalhoEditorCodigo">
                            <td class="linhaEditorCodigo">R</td>
                        </tr>
                        <tr>
                            <td class="umtab">melhorCurso <span class="rosacodigo">&#8249;-</span> <span class="amarelocodigo">"Estratégia"</span></td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="tabelaEditorCodigo">
                <table>
                    <tbody>
                        <tr class="cabecalhoEditorCodigo">
                            <td class="linhaEditorCodigo">Java</td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="azulcodigo"><em>String</em></span> melhorCurso <span class="rosacodigo">=</span> <span class="amarelocodigo">"Estratégia"</span></td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <p>Essas variáveis podem ser usadas em todo o programa? A resposta é: <strong>depende</strong>.</p>
            <p>Aas variáveis têm uma propriedade chamada de escopo. O escopo define onde poderemos usar nossa variável dentro do programa, do código da aplicação. De forma geral, temos dois tipos de escopo:</p>
            <ul>
                <li><strong>Escopo global:</strong> as variáveis podem ser acessadas (usadas) em qualquer ponto do código, seja fora ou dentro um outro bloco de código interno, como funções, métodos, classes etc.</li>
                <li><strong>Escopo local:</strong> são acessíveis somente no contexto em que foram criadas. Por exemplo, uma variável criada dentro de uma classe, só é utilizada dentro dessa classe.</li>
            </ul>
            <div class="tabelaExplica">
                <table>
                    <tbody>
                        <tr>
                            <th colspan="2">Escopo de uma variável</th>
                        </tr>
                        <tr>
                            <th>Global</th>
                            <th>Local</th>
                        </tr>
                    </tbody>
                </table>
            </div>
            <h3>Ordem de leitura</h3>
            <p>Temos três tipos de estruturas num código, que delimitam a ordem de leitura das instruções:</p>
            <ul>
                <li><strong>Estrutura sequencial: </strong>é a estrutura geral do código, que exige uma leitura sequencial do código, na ordem em que ele aparece.</li>
                <li><strong>Estrutura de seleção: </strong>são estabelecidas por sintaxes condicionais, e delimitam que apenas uma das opções deve ser escolhida. Exemplo dessa estrutura são os bloco <span class="destaqueCinza">Se...então</span>.</li>
                <li><strong>Estrutura de iteração/repetição: </strong>define um bloco de código que deve ser repetido enquanto determinada condição for obedecida. Exemplo dessa estrutura são os blocos <span class="destaqueCinza">Enquanto</span>.</li>
            </ul>
            <p>Quando estamos encarando a estrutura sequencial, determinada linha de código não tem conhecimento de nada que está escrito após ela - por isso, <strong>não podemos acessar o valor de variáveis antes de declará-las</strong>.</p>
            <p>Outro ponto importante na leitura e interpretação de códigos é a <strong>indentação</strong> - esses pequenos espaços deixados antes de começarmos um código, à esquerda dele. Ela permite uma leitura mais limpa do código, garantindo a correta interpretação da hierarquia entre os diversos objetos de um código - inclusive, em alguns formatos de arquivos de marcação, como YAML, e linguagens de programação, como o Python, a indentação é obrigatória e serve como parâmetro de interpretação do arquivo.</p>
            <p>Lembre-se: <strong>sempre endente seu código</strong>.</p>
            <h3>Operadores</h3>
            <p>Os operadores, sejam eles os matemáticos, como soma + e diferença -, ou até mesmo os comparativos, como o “maior ou igual” ≥. Na programação, esses operadores também estão presentes e ocupam um papel de destaque.</p>
            <p>Temos 3 grupos diferentes de operadores: os operadores matemáticos, os operadores relacionais e os operadores lógicos. Vamos conhecê-los! </p>
            <h3>Operadores matemáticos</h3>
            <p>Os operadores matemáticos são operadores que visam trazer operações matemáticas para o contexto da programação. Com ele, podemos criar expressões matemáticas, equações, e outras operações. Vamos a uma tabela-resumo.</p>
            <div class="tabelaExplica">
                <table>
                    <tbody>
                        <tr>
                            <th>Operador</th>
                            <th>Símbolo</th>
                            <th>Exemplo</th>
                        </tr>
                        <tr>
                            <td>Adição</td>
                            <td>+</td>
                            <td>4 + 4 == 8</td>
                        </tr>
                        <tr>
                            <td>Subtração</td>
                            <td>-</td>
                            <td>4 - 3 == 1</td>
                        </tr>
                        <tr>
                            <td>Multiplicação</td>
                            <td>*</td>
                            <td>4 * 3 == 12</td>
                        </tr>
                        <tr>
                            <td>Divisão</td>
                            <td>/</td>
                            <td>6 / 3 == 2</td>
                        </tr>
                        <tr>
                            <td>Divisão inteira</td>
                            <td>/</td>
                            <td>6 / 4 == 1</td>
                        </tr>
                        <tr>
                            <td>Exponenciação</td>
                            <td>^</td>
                            <td>3^2 == 9</td>
                        </tr>
                        <tr>
                            <td>Módulo (resto)</td>
                            <td>%</td>
                            <td>3%2 == 1</td>
                        </tr>
                        <tr>
                            <td>Incremento</td>
                            <td>++</td>
                            <td>++4 = 5</td>
                        </tr>
                        <tr>
                            <td>Decremento</td>
                            <td>--</td>
                            <td>--4 = 3</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <p><strong>Soma de Strings</strong></p>
            <p>Esse tipo de operação, na computação, recebe um nome especial: concatenação. A concatenação de textos é uma operação que faz, basicamente, a junção de dois blocos de texto. Veja, em código, como ela funciona:</p>
            <div class="tabelaEditorCodigo">
                <table>
                    <tbody>
                        <tr class="cabecalhoEditorCodigo">
                            <td class="linhaEditorCodigo">Pseudocódigo</td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="azulcodigo"><em>String</em></span> nome <span class="rosacodigo">=</span> <span class="amarelocodigo">"Felipe";</span></td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="azulcodigo"><em>String</em></span> sobrenome <span class="rosacodigo">=</span> <span class="amarelocodigo">"Martins";</span></td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="azulcodigo"><em>String</em></span> nomeCompleto <span class="rosacodigo">=</span> nome <span class="rosacodigo">+</span> sobrenome;</td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="verdecodigo">Escrever</span> (<span style="color: chocolate;"><em>nomeCompleto</em></span>) <span class="comentariocodigo">//função para mostrar o valor no terminal</span></td>
                        </tr>
                        <tr style="background-color: black;">
                            <td class="umtab">FelipeMartins</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <h3>Operadores Relacionais</h3>
            <p>Os <strong>operadores relacionais</strong> são direcionados a criar relações, comparações entre diferentes elementos. Então, temos operadores como “igual a”, “maior que”, entre outros. É importante ressaltar que <strong>o retorno</strong> de um operador relacional <strong>sempre será um valor booleano</strong>. Ou seja, o valor será verdadeiro, ou falso.</p>
            <p>Os operadores são:</p>
            <div class="tabelaExplica">
                <table>
                    <tbody>
                        <tr>
                            <th>Operador</th>
                            <th>Símbolo</th>
                            <th>Exemplo</th>
                        </tr>
                        <tr>
                            <td>Igualdade</td>
                            <td>==</td>
                            <td>4 == 4 &#8658; verdadeiro</td>
                        </tr>
                        <tr>
                            <td>Diferença</td>
                            <td>!= ou <></td>
                            <td>4 != 4 &#8658; falso</td>
                        </tr>
                        <tr>
                            <td>Maior que</td>
                            <td>></td>
                            <td>4 > 3 &#8658; verdadeiro</td>
                        </tr>
                        <tr>
                            <td>Menor que</td>
                            <td><</td>
                            <td>4 < 3 &#8658; falso</td>
                        </tr>
                        <tr>
                            <td>Maior ou igual a</td>
                            <td>>=</td>
                            <td>4 >= 4 &#8658; verdadeiro</td>
                        </tr>
                        <tr>
                            <td>Menor ou igual a</td>
                            <td><=</td>
                            <td>4 <= 4 &#8658; verdadeiro</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <h3>Operadores Lógicos</h3>
            <p>Os operadores lógicos são operadores que introduzem as operações de lógica booleana, aquela que vemos junto de raciocínio lógico matemático, dentro do panorama de programações. Na lógica booleana, temos 2 valores: valores verdadeiros, e valores falsos. Dados esses valores, podemos fazer comparações lógicas entre eles, através de 3 operadores:</p>
            <ul>
                <li><strong>E</strong></li>
                <li><strong>OU</strong></li>
                <li><strong>NÃO</strong> (ou <strong>NEGAÇÃO</strong>)</li>
            </ul>
            <p>Nos operadores relacionais, a saída será um valor booleano a partir da comparação de dois valores quaisquer. Aqui nos operadores lógicos, a saída também será um valor booleano - porém, estamos comparando outros dois valores booleanos.</p>
            <p><strong>E lógico (conjunção)</strong></p>
            <p>O comparador <strong>E lógico</strong> é usado para comparar duas expressões booleanas e <strong>resulta em verdadeiro apenas se ambas as expressões forem verdadeiras</strong>. Se uma das expressões for falsa, <strong>o resultado da operação será falso</strong>. Então, podemos ter os seguintes casos, considerando dois valores booleanos distintos:</p>
            <ul>
                <li>Verdadeiro <strong>E</strong> Verdadeiro &#8658; Verdadeiro</li>
                <li>Verdadeiro <strong>E</strong> Falso &#8658; Falso</li>
                <li>Falso <strong>E</strong> Verdadeiro &#8658; Falso</li>
                <li>Falso <strong>E</strong> Falso &#8658; Falso</li>
            </ul>
            <p><strong>OU lógico (disjunção)</strong></p>
            <p>Com o comparador <strong>OU lógico</strong>, comparamos duas expressões lógicas e temos como resultado o <strong>valor verdadeiro se algum dos dois valores comparados</strong>, <strong>ou ambos</strong>, <strong>forem verdadeiros</strong>. Ou seja, só retornaremos falso se todos os elementos forem falsos. Então, teremos os seguintes casos:</p>
            <ul>
                <li>Verdadeiro <strong>OU</strong> Verdadeiro &#8658; Verdadeiro</li>
                <li>Verdadeiro <strong>OU</strong> Falso &#8658; Verdadeiro</li>
                <li>Falso <strong>OU</strong> Verdadeiro &#8658; Verdadeiro</li>
                <li>Falso <strong>OU</strong> Falso &#8658; Falso</li>
            </ul>
            <p><strong>NÃO lógico (negação)</strong></p>
            <p>O último comparador não é bem uma comparação, já que, diferentemente doas anteriores, ele não compara dois valores, ele age em um único valor. O <strong>NÃO</strong> é responsável por “inverter” o valor de uma variável - ou seja, se ela é verdadeira, a o NÃO irá a transformar em falsa; se for falsa, o NÃO irá a transformar em verdadeira. Então, temos os seguintes casos:</p>
            <ul>
                <li><strong>NÃO</strong> Verdadeiro &#8658; Falso</li>
                <li><strong>NÃO</strong> Falso &#8658; Verdadeiro</li>
            </ul>
            <h3>Estruturas Condicionais</h3>
            <p>Na computação não é diferente, precisamos pensar em diversas situações diferentes para que um programa lide com elas. Para esses casos, surge uma estrutura basilar em toda a programação - as <strong>estruturas condicionais</strong>. Temos duas estruturas principais que você precisa saber e entender: o <strong>Se...então</strong> e o <strong>Escolha...caso</strong>.</p>
            <p>Essas estruturas são chamadas de <strong>estruturas de seleção</strong>, pois deve-se selecionar um caminho para ser seguido. Vamos entender cada uma das estruturas.</p>
            <p><strong>Se...então</strong></p>
            <p>O <strong>Se...então</strong> (ou If...Then, em inglês) é a estrutura básica das condicionais em programação. Nela, analisamos determinada situação, se ela for verificada, ou seja, <strong>se a comparação feita for de valor</strong> <span class="destaqueCinza">Verdadeiro</span>, <strong>executaremos determinado bloco de código</strong>. Veja que aqui iremos usar os operadores lógicos e relacionais.</p>
            <p>Essa condicional será composta de duas partes:</p>
            <ul>
                <li><strong><span class="destaqueCinza">Se (comparação)</span></strong> → é a comparação que será verificada, e só será aceita se o valor em (comparação) for verdadeiro</li>
                <li><strong><span class="destaqueCinza">Então: -bloco de código-</span></strong> → é o bloco de código executado se for a</li>
            </ul>
            <p>Exemplo de código:</p>
            <div class="tabelaEditorCodigo">
                <table>
                    <tbody>
                        <tr class="cabecalhoEditorCodigo">
                            <td class="linhaEditorCodigo">Pseudocódigo</td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="azulcodigo"><em>String</em></span> Nota_do_aluno <span class="rosacodigo">=</span> <span class="roxocodigo">6</span>;</td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="azulcodigo"><em>String</em></span> Situação_do_aluno <span class="rosacodigo">=</span> <span class="verdelevecodigo">" "</span>;</td>
                        </tr>
                        <tr>
                            <td class="umtab"></td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="amarelocodigo">Se</span> (Nota_do_aluno <span class="rosacodigo">&#62 =</span> <span class="roxocodigo">7</span>)<span class="amarelocodigo"> Então:</span></td>
                        </tr>
                        <tr>
                            <td class="doistab"></span> Situação_do_aluno <span class="rosacodigo">=</span> <span class="verdelevecodigo">"Aprovado"</span>;</td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="amarelocodigo">Se</span> (Nota_do_aluno <span class="rosacodigo">&#60</span> <span class="roxocodigo">7</span> <span class="rosacodigo">&#38&#38</span> Nota_do_aluno <span class="rosacodigo">&#62 =</span> <span class="roxocodigo">5</span>)<span class="amarelocodigo"> Então:</span></td>
                        </tr>
                        <tr>
                            <td class="doistab"></span> Situação_do_aluno <span class="rosacodigo">=</span> <span class="verdelevecodigo">"Recuperação"</span>;</td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="amarelocodigo">Senão:</span></td>
                        </tr>
                        <tr>
                            <td class="doistab"></span> Situação_do_aluno <span class="rosacodigo">=</span> <span class="verdelevecodigo">"Reprovado"</span>;</td>
                        </tr>
                                                <tr>
                            <td class="umtab"><span class="amarelocodigo">Fim Se</span></td>
                        </tr>
                        <tr>
                            <td class="umtab"></td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="verdecodigo">Escrever</span> (Situação_do_aluno)</td>
                        </tr>
                        <tr style="background-color: black;">
                            <td class="umtab">Recuperação</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <p><strong>Escolha...caso</strong></p>
            <p>O Escolha...caso (também chamado de Switch...case) é um formato de condicional para seleções múltiplas, adequado quando temos um conjunto de condições serem verificadas. Cada caso irá analisar uma condição diferente, e, se for verificada a condição desse caso específico, ela será implementada. Terminamos o bloco de Escolha...caso com um senão, que será uma opção residual: se nenhuma outra condição tiver a sua veracidade verificada, ativaremos esse bloco.</p>
            <p>Exemplo de código:</p>
            <div class="tabelaEditorCodigo">
                <table>
                    <tbody>
                        <tr class="cabecalhoEditorCodigo">
                            <td class="linhaEditorCodigo">Pseudocódigo</td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="azulcodigo"><em>String</em></span> Nota_do_aluno <span class="rosacodigo">=</span> <span class="roxocodigo">6</span>;</td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="azulcodigo"><em>String</em></span> Situação_do_aluno <span class="rosacodigo">=</span> <span class="verdelevecodigo">" "</span>;</td>
                        </tr>
                        <tr>
                            <td class="umtab"></td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="amarelocodigo">Escolha</span></td>
                        </tr>
                        <tr>
                            <td class="doistab"><span class="amarelocodigo">Caso</span> (Nota_do_aluno <span class="rosacodigo">&#62 =</span> <span class="roxocodigo">7</span>)<span class="amarelocodigo"> Faça:</span></td>
                        </tr>
                        <tr>
                            <td class="trestab"></span> Situação_do_aluno <span class="rosacodigo">=</span> <span class="verdelevecodigo">"Aprovado"</span>;</td>
                        </tr>
                        <tr>
                            <td class="doistab"><span class="amarelocodigo">Caso</span> (Nota_do_aluno <span class="rosacodigo">&#60</span> <span class="roxocodigo">7</span> <span class="rosacodigo">&#38&#38</span> Nota_do_aluno <span class="rosacodigo">&#62 =</span> <span class="roxocodigo">5</span>)<span class="amarelocodigo"> Faça:</span></td>
                        </tr>
                        <tr>
                            <td class="trestab"></span> Situação_do_aluno <span class="rosacodigo">=</span> <span class="verdelevecodigo">"Recuperação"</span>;</td>
                        </tr>
                        <tr>
                            <td class="doistab"><span class="amarelocodigo">Senão:</span></td>
                        </tr>
                        <tr>
                            <td class="trestab"></span> Situação_do_aluno <span class="rosacodigo">=</span> <span class="verdelevecodigo">"Reprovado"</span>;</td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="amarelocodigo">Fim Escolha</span></td>
                        </tr>
                        <tr>
                            <td class="umtab"></td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="verdecodigo">Escrever</span> (Situação_do_aluno)</td>
                        </tr>
                        <tr style="background-color: black;">
                            <td class="doistab">Recuperação</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <h3>Estruturas de Repetição</h3>
            <p>Imagine que você precise criar um código que irá Escrever, no terminal, os números de 1 a 1.000.000. De uma forma rudimentar, baseada na “força bruta”, você poderia escrever o código da seguinte forma:</p>
            <div class="tabelaEditorCodigo">
                <table>
                    <tbody>
                        <tr class="cabecalhoEditorCodigo">
                            <td class="linhaEditorCodigo">Pseudocódigo</td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="verdecodigo">Escrever</span>(<span class="rosacodigo">1</span>)</td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="verdecodigo">Escrever</span>(<span class="rosacodigo">2</span>)</td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="verdecodigo">Escrever</span>(<span class="rosacodigo">3</span>)</td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="rosacodigo">...</span></td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="verdecodigo">Escrever</span>(<span class="rosacodigo">999999</span>)</td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="verdecodigo">Escrever</span>(<span class="rosacodigo">1000000</span>)</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <p>Já pensou o trabalho que seria escrever cada uma dessas linhas? 1 milhão de linhas para um programa relativamente simples. Para resolver esses problemas, assim como implementar mais dinamicidade nos códigos, entram em voga as <strong>estruturas de repetição</strong> (também chamadas de estruturas de iteração) . Nela, repetiremos determinado bloco de código conforme a condição de verificação. Esse tipo de estrutura pode ser chamada de <strong>loop</strong>, em inglês, e cada repetição do bloco é chamada de <strong>iteração</strong>, ou <strong>laço</strong>.</p>
            <p>Temos 4 formas de repetição que iremos abordar:</p>
            <ul>
                <li><strong>Enquanto</strong></li>
                <li><strong>Repita...até</strong></li>
                <li><strong>Faça...enquanto</strong></li>
                <li><strong>Para</strong></li>
            </ul>
            <h4>Enquanto</h4>
            <p>O <strong><span class="destaqueCinza">Enquanto</span></strong> (ou While) é uma estrutura de repetição que irá repetir determinado bloco de código <strong>enquanto a condição de verificação tiver valor <span class="destaqueCinza">Verdadeiro</span></strong>. Aqui, a verificação é feita antes de iniciarmos a execução, se o valor for verdadeiro, seguimos em frente na execução; caso contrário, a repetição é terminada.</p>
            <p>Vamos refazer a nossa contagem de 1 a 1.000.000 com a estrutura do <span class="destaqueCinza">Enquanto</span>. Para isso, criaremos uma variável para comportar os números, chamada de <span class="destaqueCinza">contagem</span>, e, a cada laço do <span class="destaqueCinza">Enquanto</span>, iremos fazer um incremento nessa variável, usando o operador ++. Lembrando que esse código será executado enquanto a variável <span class="destaqueCinza">contagem</span> for menor ou igual a 1.000.000. O código ficará da seguinte forma:</p>
            <div class="tabelaEditorCodigo">
                <table>
                    <tbody>
                        <tr class="cabecalhoEditorCodigo">
                            <td class="linhaEditorCodigo">Pseudocódigo</td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="azulcodigo"><em>int</em></span> contagem <span class="rosacodigo">=</span> <span class="roxocodigo">1</span></td>
                        </tr>
                        <tr>
                            <td class="umtab"></td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="amarelocodigo">Enquanto</span> (contagem <span class="rosacodigo">&#60 =</span> <span class="roxocodigo">1000000</span>)<span class="amarelocodigo"> Faça:</span></td>
                        </tr>
                        <tr>
                            <td class="doistab"><span class="verdecodigo">Escrever</span>(contagem)</td>
                        </tr>
                        
                        <tr>
                            <td class="doistab">contagem<span class="rosacodigo">++</span></td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="amarelocodigo">Fim Enquanto</span></td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <h4>Repita...Enquanto</h4>
            <p>A segunda forma de estrutura de repetição, o <span class="destaqueCinza"><strong>Repita...até</strong></span>, que também pode aparecer como <span class="destaqueCinza"><strong>Faça...até</strong></span>, é uma estrutura muito similar ao enquanto - porém, <strong>a verificação da condição é feita após a execução do bloco de código</strong>. Então, aqui, mesmo que a condição não seja satisfeita, iremos executar o bloco de código ao menos uma vez. Além disso, aqui o bloco de código é <strong>executado enquanto a condição for falsa</strong>. Se a condição for implementada, verdadeira, sairemos do bloco.</p>
            <p>Vamos pegar o mesmo código que usamos anteriormente, no Enquanto, e aplicá-lo aqui.</p>
            <div class="tabelaEditorCodigo">
                <table>
                    <tbody>
                        <tr class="cabecalhoEditorCodigo">
                            <td class="linhaEditorCodigo">Pseudocódigo</td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="azulcodigo"><em>int</em></span> contagem <span class="rosacodigo">=</span> <span class="roxocodigo">1</span></td>
                        </tr>
                        <tr>
                            <td class="umtab"></td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="amarelocodigo">Repita:</span></td>
                        </tr>
                        <tr>
                            <td class="doistab"><span class="verdecodigo">Escrever</span>(contagem)</td>
                        </tr>
                        
                        <tr>
                            <td class="doistab">contagem<span class="rosacodigo">++</span></td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="amarelocodigo">Até</span> (contagem <span class="rosacodigo">></span> <span class="roxocodigo">1000000</span>)</td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="amarelocodigo">Fim Repita</span></td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <p>Se você respondeu 1.000.001, parabéns! Você entendeu a <strong>ordem de interpretação de um código</strong>. Veja bem, quando tivermos o valor 1.000.000, a verificação <span class="destaqueCinza">contagem ≤ 1.000.000</span> ainda será verdadeira - o que quer dizer que iremos executar mais uma vez o código. Dessa vez, o valor de contagem será levado a 1.000.001, e, na verificação da condição, não teremos mais o valor <span class="destaqueCinza">Verdadeiro</span> e iremos romper o loop.</p>
            <h4>Faça...Enquanto</h4>
            <p>O <span><strong>Faça...enquanto</strong></span>, ou <span>Do...while</span>, é uma estrutura de repetição muito semelhante ao Repita...até, mas com algumas diferenças “grandes”. Ele também executará, obrigatoriamente, um bloco de código - e irá executá-lo repetidas vezes, <strong>desde que a condição de verificação seja verdadeira</strong>.</p>
            <p>Veja que já temos uma primeira diferença - o Faça...enquanto irá executar as instruções enquanto a condição for verdadeira. Uma segunda diferença é o momento da verificação da condição: apesar de executar um bloco independentemente do que ocorra, o Faça...enquanto verifica a condição <strong>antes</strong> de executar o bloco uma vez, enquanto o Repita...até verifica depois. Então, resumindo:</p>
            <div class="tabelaExplica">
                <table>
                    <tbody>
                        <tr>
                            <th>Aspecto</th>
                            <th>Repita...até</th>
                            <th>Faça...enquanto</th>
                        </tr>
                        <tr>
                            <td class="destaque">Tipo de Estrutura</td>
                            <td>Repetição (loop)</td>
                            <td>Repetição (loop)</td>
                        </tr>
                        <tr>
                            <td class="destaque">Executa o bloco ao menos uma vez</td>
                            <td>Sim</td>
                            <td>Sim</td>
                        </tr>
                        <tr>
                            <td class="destaque">Verificação de condição</td>
                            <td>Depois de executar o primeiro bloco</td>
                            <td>Antes de executar o primeiro bloco</td>
                        </tr>
                        <tr>
                            <td class="destaque">Encerramento do Loop</td>
                            <td>Quando a condição se tornar VERDADEIRA</td>
                            <td>Quando a condição se tornar FALSA</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <h4>Para</h4>
            <p>A estrutura de repetição <strong>Para</strong> é uma estrutura destinada a uso quando você já sabe quantas iterações, quantos laços do loop você quer que sejam realizados. No Para, definimos um <strong>valor inicial, um valor final e quanto esse valor será incrementado (ou decrementado) a cada laço</strong> - servindo como forma de controle para quantas iterações teremos.</p>
            <p>O uso do Para passa a ser interessante quando o valor da variável local declarada é útil para o contexto do loop. Por exemplo, na nossa contagem de 1 a 1.000.000, podemos fazer a execução do nosso programa numa forma bem reduzida. Aqui, utilizarei a variável local i, que iniciará em 0 e irá até 1.000.000, incrementando em 1 unidade a cada laço. Utilizarei essa mesma variável local no comando Escrever(), dentro do bloco de código, para que esse valor seja impresso. Veja como diminuímos o tamanho do código:</p>
            <div class="tabelaEditorCodigo">
                <table>
                    <tbody>
                        <tr class="cabecalhoEditorCodigo">
                            <td class="linhaEditorCodigo">Pseudocódigo</td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="amarelocodigo">Para</span> i <span class="amarelocodigo">de</span> 1 <span class="amarelocodigo">a</span> 1000000 <span class="amarelocodigo">Faça</span></td>
                        </tr>
                        <tr>
                            <td class="doistab"><span class="verdecodigo">Escrever</span>(contagem)</td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="amarelocodigo">Fim Para</span></td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <h3>Estruturas de Desvio</h3>
            <p>Pode ser que determinadas linhas de código só precisem ser executadas se determinada condição for (ou não for) satisfeita. Por exemplo, se determinada condição for falsa, pode ser que tenhamos que executar uma série de salvaguardas para proteger a aplicação, como numa tentativa de invasão de hackers. Porém, se a condição for verdadeira, esse determinado bloco não seria executado.</p>
            <p>Embora muitas estruturas que vimos podem agir implementando esse “salto” de linhas, como, por exemplo, uma estrutura condicional, temos uma estrutura específica para esses casos: é a <strong>estrutura de desvio incondicional</strong> - representada nos algoritmos por <span class="destaqueCinza"><strong>Vá para</strong></span>, ou, em inglês, Go to. Apesar de não termos essa limitação em pseudocódigo, essa estrutura de desvio não é suportada nativamente por diversas linguagens, necessitando de uma adaptação através de funções.</p>
            <p>Veja um exemplo:</p>
            <div class="tabelaEditorCodigo">
                <table>
                    <tbody>
                        <tr class="cabecalhoEditorCodigo">
                            <td class="linhaEditorCodigo">Pseudocódigo</td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="azulcodigo"><em>Inicio</em></span></td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="azulcodigo"><em>int</em></span> nota</td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="azulcodigo"><em>String</em></span> situaçao</td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="amarelocodigo">Se</span> (nota <span class="rosacodigo">> =</span> <span class="roxocodigo">7</span> ) <span class="amarelocodigo">Então</span></td>
                        </tr>
                        <tr>
                            <td class="doistab">Situaçao <span class="rosacodigo">=</span> <span class="verdelevecodigo">"Aprovado"</span></td>
                        </tr>
                        <tr>
                            <td class="doistab"><span class="amarelocodigo">Vá_para</span> <span class="azulcodigo"><em>Fim</em></span></td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="amarelocodigo">Fim Se</span></td>
                        </tr>
                        <tr>
                            <td></td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="verdecodigo">Função Prova_de_Recuperação</span>( ) {</td>
                        </tr>
                        <tr>
                            <td class="doistab"><span class="comentariocodigo">//bloco de código</span></td>
                        </tr>
                        <tr>
                            <td class="umtab">}</td>
                        </tr>
                        <tr>
                            <td></td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="amarelocodigo">Se (nota <span class="rosacodigo"><</span> <span class="roxocodigo">5</span>) <span class="amarelocodigo">Então</span></span></td>
                        </tr>
                        <tr>
                            <td class="umtab">Situaçao <span class="rosacodigo">=</span> <span class="verdelevecodigo">"Reprovado"</span></td>
                        </tr>
                        <tr>
                            <td class="doistab"><span class="amarelocodigo">Fim Se</span></td>
                        </tr>
                        <tr>
                            <td></td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="azulcodigo"><em>Fim</em></span></td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <p>No exemplo acima, pularemos toda a parte do código necessário para gerar uma prova de recuperação, caso a nota do aluno seja maior ou igual a 7. Outros casos comuns de uso do Vá para envolvem loops aninhados - onde, se determinada condição no loop interno for satisfeita, usamos um comando de desvio para encerrar o loop total, tanto interno quanto externo.</p>
            <h3>Estruturas de Dados</h3>
            <p>As <strong>Estruturas de Dados</strong> são formas de agruparmos diversos valores em uma única variável. Esses assuntos são vistos com mais profundidade em aula específica, mas, como muitas questões de lógica de programação exigem conhecimentos acerca desses assuntos, vou passar um panorama geral para você do que é cada estrutura de dados. Veremos 6 estruturas na aula de hoje:</p>
            <ul>
                <li>Vetores</li>
                <li>Listas</li>
                <li>Filas</li>
                <li>Pilhas</li>
                <li>Matrizes</li>
                <li>Registros</li>
            </ul>
            <h4>Vetores</h4>
            <p>Os vetores, também referenciados pelo seu nome em inglês, array, são estruturas de dados homogêneas, isso é, recebem somente um tipo de dado, que comportam uma coleção de dados ordenados. Além disso, eles são um tipo de estrutura unidimensional, ou seja, os dados são agrupados em uma única direção, formando uma lista de dados. Para declararmos vetores, vamos usar o seguinte padrão:</p>
            <div style="text-align: left; padding: 6px;"><img width="800px" src="img/vetores.png" alt=""></div>
            <p>Então, por exemplo, imagine a seguinte declaração:</p>
            <div class="tabelaEditorCodigo">
                <table>
                    <tbody>
                        <tr class="cabecalhoEditorCodigo">
                            <td class="linhaEditorCodigo">Pseudocódigo</td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="azulcodigo"><em>int</em></span> vetorNumeros <span class="rosacodigo">=</span> vetor [<span class="roxocodigo">1</span>, <span class="roxocodigo">2</span>, <span class="roxocodigo">3</span>, <span class="roxocodigo">4</span>, <span class="roxocodigo">5</span>]</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <p>Cada elemento, desses 5 atribuídos ao vetor, é delimitado por uma posição - chamada de índice. Esse índice, ou index em inglês, é útil para acessarmos determinado valor dentro do vetor. Usualmente, começa-se a contagem de posições a partir do 0. Portanto, o primeiro elemento terá a posição 0, e incrementamos a posição de 1 em 1. Veja:</p>
            <div style="text-align: left; padding: 6px;"><img width="500px" src="img/vetores2.png" alt=""></div>
            <p>Para acessarmos determinado elemento do vetor, basta delimitarmos a posição desse elemento dentro de um par de colchetes - veja:</p>
            <div class="tabelaEditorCodigo">
                <table>
                    <tbody>
                        <tr class="cabecalhoEditorCodigo">
                            <td class="linhaEditorCodigo">Pseudocódigo</td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="azulcodigo"><em>int</em></span> vetorNumeros <span class="rosacodigo">=</span> vetor [<span class="roxocodigo">1</span>, <span class="roxocodigo">2</span>, <span class="roxocodigo">3</span>, <span class="roxocodigo">4</span>, <span class="roxocodigo">5</span>]</td>
                        </tr>
                        <tr>
                            <td></td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="verdecodigo">Escrever</span>(vetorNumeros[<span class="roxocodigo">2</span>])</td>
                        </tr>
                        <tr>
                            <td></td>
                        </tr>
                        <tr style="background-color: black;">
                            <td class="umtab">3</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <h4>Listas</h4>
            <p>As <strong>listas</strong> são uma estrutura de dados que comportam uma multiplicidade de valores de forma ordenada, assim como os vetores - mas elas tem algumas diferenças basilares entre si. Enquanto os vetores são estáticos, as <strong>listas são dinâmicas</strong>, isso é, permitem a inserção e remoção de elementos livremente, já que não temos um tamanho fixo.</p>
            <p>Veja uma comparação:</p>
            <div class="tabelaExplica">
                <table>
                    <tbody>
                        <tr>
                            <th>Aspecto</th>
                            <th>Vetores</th>
                            <th>Listas</th>
                        </tr>
                        <tr>
                            <th>Tamanho</th>
                            <td>Fixo</td>
                            <td>Variável</td>
                        </tr>
                        <tr>
                            <th>Acesso</th>
                            <td>Diretamente por índice</td>
                            <td>Acesso sequencial</td>
                        </tr>
                        <tr>
                            <th>Inserção/Remoção</th>
                            <td>Envolve operações complexas, como cópias e deslocamentos</td>
                            <td>Inserção e remoção livres</td>
                        </tr>
                        <tr>
                            <th>Flexibilidade</th>
                            <td>Baixa</td>
                            <td>Alta</td>
                        </tr>
                        <tr>
                            <th>Memória</th>
                            <td>Ocupa espaços contíguos</td>
                            <td>Não há uma delimitação, podendo resultar em fragmentação</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <p>Imagine uma lista enorme, com 1.000 números. A complexidade de escrever os valores manualmente, como fizemos no vetor, passa a ser maior, não é? Para resolver isso, podemos começar com uma lista vazia, e alimentá-la através de operações de atribuição (+=) dentro de um loop. Veja como ficaria.</p>
            <div class="tabelaEditorCodigo">
                <table>
                    <tr class="cabecalhoEditorCodigo">
                        <td class="umtab">Pseudocódigo</td>
                    </tr>
                    <tr>
                        <td class="umtab"><span class="azulcodigo"><em>int</em></span> listaLonga <span class="rosacodigo">=</span> lista []</td>
                    </tr>
                    <tr>
                        <td class="umtab"></td>
                    </tr>
                    <tr>
                        <td class="umtab"><span class="amarelocodigo">Para</span> (i <span class="rosacodigo">=</span> <span class="roxocodigo">1</span>; i <span class="rosacodigo">< =</span> <span class="roxocodigo">1000</span>; i<span class="rosacodigo">++</span>) Faça<span class="rosacodigo">:</span></td>
                    </tr>
                    <tr>
                        <td class="doistab">listaLonga <span class="rosacodigo">+=</span> i</td>
                    </tr>
                    <tr>
                        <td class="umtab"><span class="amarelocodigo">Fim Para</span></td>
                    </tr>
                </table>
            </div>
            <h4>Filas</h4>
            <p>As <strong>filas</strong>, ou <strong>queues</strong>, são estruturas de dados homogêneas e unidimensionais, assim como as listas - mas possuem uma propriedade especial: as inserções e remoções da sua estrutura utilizam a regra <strong>“primeiro a entrar, primeiro a sair”</strong> - ou <strong>FIFO</strong> (“First In, First Out”). Ou seja, sempre que formos inserir um elemento na estrutura, ele será inserido no fim da fila, e quando retirarmos algum dado, o primeiro dado da fila será retirado.</p>
            <p><img src="img/filas.png" alt="Filas / Queues"></p>
            <p>
                <ul>
                    <li><strong>Enfileirar (enqueue)</strong>: adicionar um elemento ao final da fila</li>
                    <li><strong>Desenfileirar (dequeue)</strong>: retirar um elemento do começo da fila</li>
                    <li><strong>Frente (front</strong>): obter o valor do elemento que está na frente da fila</li>
                </ul>
            </p>
            <h4>Pilhas</h4>
            <p>As <strong>pilhas</strong>, ou <strong>stacks</strong>, assim como as filas, são estruturas de dados homogêneas e unidimensionais. Aqui, novamente, temos uma estrutura diferenciada, utilizando o padrão “Último a Entrar, Primeiro a Sair” - ou LIFO (“Last In, First Out”). Pense num pacote de Pringles - a última batata adicionada ao pacote será aquela no topo do tubo, e essa também será a primeira a ser retirada. A estrutura em pilha funciona da mesma forma.</p>
            <p><img src="img/pilhas.png" alt="Pilhas / Stacks"></p>
            <p>As operações relacionadas à pilha são:</p>
            <ul>
                <li><strong>Empilhar ou empurrar (push):</strong> adicionar um elemento ao topo da pilha</li>
                <li><strong>Desempilhar ou puxar (pop):</strong> remove um elemento do topo da pilha</li>
                <li><strong>Topo (top):</strong> retorna o valor do elemento no topo da pilha</li>
            </ul>
            <h4>Matrizes</h4>
            <p>As <strong>matrizes</strong> são <strong>estruturas de dados homogêneas</strong>, assim como os vetores - mas a principal diferença aqui é que passamos a trabalhar com <strong>duas dimensões</strong>. Assim, passamos a trabalhar com <strong>índices em duas dimensões</strong> - <strong>a dimensão horizontal e vertical</strong>. Pense em uma estrutura similar a uma matriz que você estudou em matemática, no ensino médio.</p>
            <p>Para declararmos uma matriz é simples, temos um processos similar ao da lista - porém, ao delimitarmos os colchetes, cada linha será delimitada por um outro par de colchetes internos. Veja uma estrutura geral:</p>
            <p><img src="img/matrizes.png" alt="Matrizes"></p>
            <p>Assim como nos vetores, podemos acessar os elementos da matriz através de seu índice. Porém, agora temos 2 eixos para verificar a posição, assim sendo necessário dois argumentos ao especificarmos o dado que queremos recuperar. Por exemplo, matriz [0, 0] irá retornar o primeiro elemento, da primeira linha.</p>
            <p>Veja um exemplo em uma tabela - nela, iremos selecionar o elemento matriz [2, 3], onde 2 representa a linha, e 3 a coluna.</p>
            <div class="tabelaExplica">
                <table>
                    <tbody>
                        <tr>
                            <th>Índice</th>
                            <th>0</th>
                            <th>1</th>
                            <th>2</th>
                            <th>3</th>
                            <th>4</th>
                        </tr>
                        <tr>
                            <th>0</th>
                            <td>Brasil</td>
                            <td>EUA</td>
                            <td>Canadá</td>
                            <td>México</td>
                            <td>Bolívia</td>
                        </tr>
                        <tr>
                            <th>1</th>
                            <td>Japão</td>
                            <td>Egito</td>
                            <td>Gana</td>
                            <td>China</td>
                            <td>Bélgica</td>
                        </tr>
                        <tr>
                            <th>2</th>
                            <td>Argentina</td>
                            <td>Itália</td>
                            <td>Inglaterra</td>
                            <td style="background-color: rgb(112, 212, 112);">Peru</td>
                            <td>Austrália</td>
                        </tr>
                        <tr>
                            <th>3</th>
                            <td>Rússia</td>
                            <td>Nepal</td>
                            <td>Holanda</td>
                            <td>Cuba</td>
                            <td>Líbia</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <p>Em termos de sintaxe, poderíamos montar essa tabela e selecionar o mesmo elemento da seguinte forma:</p>
            <div class="tabelaEditorCodigo">
                <table>
                    <tbody>
                        <tr class="cabecalhoEditorCodigo">
                            <td class="linhaEditorCodigo">Pseudocódigo</td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="azulcodigo"><em>int</em></span> matrizPaises <span class="rosacodigo">=</span> matriz [</td>
                        </tr>
                        <tr>
                            <td class="doistab">["<span class="amarelocodigo">Brasil</span>", "<span class="amarelocodigo">EUA</span>", "<span class="amarelocodigo">Canadá</span>", "<span class="amarelocodigo">México</span>", "<span class="amarelocodigo">Bolívia</span>"],</td>
                        </tr>
                        <tr>
                            <td class="doistab">["<span class="amarelocodigo">Japão</span>", "<span class="amarelocodigo">Egito</span>", "<span class="amarelocodigo">Gana</span>", "<span class="amarelocodigo">China</span>", "<span class="amarelocodigo">Bélgica</span>"],</td>
                        </tr>
                        <tr>
                            <td class="doistab">["<span class="amarelocodigo">Argentina</span>", "<span class="amarelocodigo">Itália</span>", "<span class="amarelocodigo">Inglaterra</span>", "<span class="amarelocodigo">Peru</span>", "<span class="amarelocodigo">Austrália</span>"],</td>
                        </tr>
                        <tr>
                            <td class="doistab">["<span class="amarelocodigo">Russia</span>", "<span class="amarelocodigo">Nepal</span>", "<span class="amarelocodigo">Holanda</span>", "<span class="amarelocodigo">Cuba</span>", "<span class="amarelocodigo">Líbia</span>"]]</td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="verdecodigo">Escrever</span>(matrizPaises[<span class="roxocodigo">2</span>, <span class="roxocodigo">3</span>])</td>
                        </tr>
                        <tr style="background-color: black;">
                            <td class="umtab">Peru</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <h4>Registros</h4>
            <p>O <strong>registro</strong> é uma estrutura de dados <strong>heterogênea</strong>, ou seja, agrupa diferentes tipos de dado numa mesma variável. Ele é usado para representar entidades ou objetos complexos, nos quais cada campo dentro do registro armazena um tipo específico de informação.</p>
            <p>Em um registro, cada campo possui um nome único que o identifica e um tipo de dado associado que define o tipo de informação que pode ser armazenada nele. Por exemplo, em um registro de Pessoa, poderíamos ter campos como "nome" (String), "idade" (inteiro), "altura" (real), etc.</p>
            <p>Quando definimos um registro, definimos um "esqueleto" de estrutura, sem passar nenhum valor para a variável. Posteriormente, podemos criar variáveis derivadas desse esqueleto, com toda a sua estrutura implementada. Vamos para um exemplo!</p>
            <div class="tabelaEditorCodigo">
                <table>
                    <tbody>
                        <tr class="cabecalhoEditorCodigo">
                            <td class="linhaEditorCodigo">Pseudocódigo</td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="amarelocodigo">registro</span> Pessoa</td>
                        </tr>
                        <tr>
                            <td class="doistab">Nome<span class="rosacodigo">:</span> <span class="azulcodigo"><em>String</em></span></td>
                        </tr>
                        <tr>
                            <td class="doistab">Idade<span class="rosacodigo">:</span> <span class="azulcodigo"><em>Int</em></span></td>
                        </tr>
                        <tr>
                            <td class="doistab">Altura<span class="rosacodigo">:</span> <span class="azulcodigo"><em>Float</em></span></td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="amarelocodigo">fim Registro</span></td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <p>Com isso, criamos uma estrutura de registro. Agora, podemos declarar variáveis conforme essa estrutura, que vai funcionar como um "tipo de dado" para a variável declarada. Assim, podemos passar valores para os diferentes identificadores internos da entidade. Vamos fazer duas atribuições, para que você possa entender melhor.</p>
            <div class="tabelaEditorCodigo">
                <table>
                    <tbody>
                        <tr class="cabecalhoEditorCodigo">
                            <td class="linhaEditorCodigo">Pseudocódigo</td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="azulcodigo"><em>Pessoa</em></span> pessoa1</td>
                        </tr>
                        <tr>
                            <td class="umtab">pessoa1.nome <span class="rosacodigo">=</span> <span class="amarelocodigo">"Felipe"</span></td>
                        </tr>
                        <tr>
                            <td class="umtab">pessoa1.idade <span class="rosacodigo">=</span> <span class="roxocodigo">30</span></td>
                        </tr>
                        <tr>
                            <td class="umtab">pessoa1.altura <span class="rosacodigo">=</span> <span class="roxocodigo">1.88</span></td>
                        </tr>
                        <tr>
                            <td class="umtab"></td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="azulcodigo"><em>Pessoa</em></span> pessoa2</td>
                        </tr>
                        <tr>
                            <td class="umtab">pessoa2.nome <span class="rosacodigo">=</span> <span class="amarelocodigo">"Milena"</span></td>
                        </tr>
                        <tr>
                            <td class="umtab">pessoa2.idade <span class="rosacodigo">=</span> <span class="roxocodigo">24</span></td>
                        </tr>
                        <tr>
                            <td class="umtab">pessoa2.altura <span class="rosacodigo">=</span> <span class="roxocodigo">1.62</span></td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <p>Veja que “navegamos” através das diferentes variáveis dentro do registro através de um ponto - por exemplo, em pessoa1.nome, estou atribuindo um valor para a propriedade nome, da variável pessoa1. Isso permite também que retornemos esse valor através de uma seleção, assim como fizemos com os vetores e as matrizes.</p>
            <h3>Rotinas</h3>
            <h4>Funções e Procedimentos</h4>
            <p>À medida que encontramos problemas cada vez mais complexos, é necessário quebrarmos um programa geral em diversos outros programas menores, "subprogramas", cada qual com uma funcionalidade definida. Essas pequenas partes que formam o programa são chamados de rotinas. As rotinas facilitam a execução e legibilidade do código, além de adicionar a modularidade ao programa - já que definimos determinada funcionalidade, ela pode ser replicada em outros pontos do código, quando for necessário.</p>
            <p>Existem dois tipos de rotinas na programação: as <strong>funções</strong> e os <strong>procedimentos</strong>. A principal diferença entre ambas está no retorno. <strong>Funções trazem algum retorno ao código, enquanto procedimentos não</strong>. Esse retorno é algum valor que afeta o código, que pode ser usado por outras variáveis - usualmente caracterizado pelo uso da palavra <span class="destaqueCinza">Retorne</span>.</p>
            <p class="destaqueVermelho">Procedimento > Não retorna um valor</p>
            <p class="destaqueVermelho">Função >  Retorna um valor</p>
            <p>Para declararmos uma função, usaremos a seguinte estrutura:</p>
            <p>
                <span style="padding: 5px 0px 5px 30px;"><strong>Função</strong> (parâmetros):</span>
                <span style="padding: 5px 0px 5px 60px;">Bloco de código</span>
                <span style="padding: 5px 0px 5px 30px;"><strong>Fim Função</strong></span>
            </p>
            <p>Para entendermos melhor como implementar essa estrutura, precisamos entender os <strong>parâmetros</strong>.</p>
            <h4>Parâmetros</h4>
            <p>os <strong>parâmetros</strong> (também chamados de argumentos) em funções <strong>são variáveis locais</strong> que são especificadas como parte da definição de uma função e que recebem valores quando a função é chamada ou invocada. Eles servem como mecanismo para passar informações para dentro de uma função, permitindo que ela trabalhe com valores específicos.</p>
            <p>Quando uma função é definida, os parâmetros são listados entre parênteses após o nome da função. Por exemplo, em uma função que calcula a soma de dois números, os parâmetros seriam os dois números que estão sendo somados. Quando a função é chamada, os valores passados como argumentos para os parâmetros são atribuídos às variáveis de parâmetro dentro da função, permitindo que ela os utilize em suas operações internas.</p>
            <p>Você pode não ter percebido, mas quando lhe expliquei a função exponencial, usamos os parâmetros. Vamos relembrar:</p>
            <p>
                <span style="padding: 5px 0px 5px 30px;">Função exp(a, b)</span>
                <span style="padding: 5px 0px 5px 60px;">retorne a^b</span>
                <span style="padding: 5px 0px 5px 30px;"><strong>Fim Função</strong></span>
            </p>
            <p>Aqui, temos os parâmetros a e b. Como é uma função de exponenciação, o parâmetro a será nossa base, e o parâmetro b o expoente. Assim, toda vez que chamarmos uma função, passaremos os parâmetros que queremos calcular. Por exemplo podemos achar 3² passando a função exp(3,2), ou 3³ passando a função exp(3,3).</p>
            <p>Veja mais um exemplo de uma função simples.</p>
            <div class="tabelaEditorCodigo">
                <table>
                    <tbody>
                        <tr class="cabecalhoEditorCodigo">
                            <td class="linhaEditorCodigo">Pseudocódigo</td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="verdecodigo">Função soma</span> (a, b)</td>
                        </tr>
                        <tr>
                            <td class="doistab">retorne a <span class="rosacodigo">+</span> b</td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="verdecodigo">Fim Função</span></td>
                        </tr>
                        <tr>
                            <td class="umtab"></td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="verdecodigo">Escrever</span>(<span class="verdecodigo">soma</span>(<span class="roxocodigo">3</span>, <span class="roxocodigo">4</span>))</td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="verdecodigo">Escrever</span>(<span class="verdecodigo">soma</span>(<span class="roxocodigo">2</span>, <span class="roxocodigo">2</span>))</td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="verdecodigo">Escrever</span>(<span class="verdecodigo">soma</span>(<span class="roxocodigo">3</span>, <span class="roxocodigo">9</span>))</td>
                        </tr>
                        <tr style="background-color: black;">
                            <td class="umtab">7</td>
                        </tr>
                        <tr style="background-color: black;">
                            <td class="umtab">4</td>
                        </tr>
                        <tr style="background-color: black;">
                            <td class="umtab">12</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <p>Na sintaxe acima, temos dois parâmetros: <strong>a</strong> e <strong>b</strong>. Ao chamarmos a função, passamos os valores substituindo os parâmetros - esses valores podem ser declarações diretas de números, como fizemos ou referências a outras variáveis. A função irá somar ambos os números e retornar o resultado.</p>
            <p>Podemos também fazer funções mais avançadas, com blocos de códigos extensos - incluindo outras funções locais, declaração de variáveis locais, entre outros. Vamos fazer um exemplo, uma função que irá identificar se determinado valor é par ou não.</p>
            <div class="tabelaEditorCodigo">
                <table>
                    <tbody>
                        <tr class="cabecalhoEditorCodigo">
                            <td class="linhaEditorCodigo">Pseudocódigo</td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="verdecodigo">Função par</span>(i)</td>
                        </tr>
                        <tr>
                            <td class="doistab"><span class="amarelocodigo">Se</span> (i<span class="rosacodigo">%</span><span class="roxocodigo">2</span> <span class="rosacodigo">==</span> <span class="roxocodigo">0</span>) <span class="amarelocodigo">Então</span></td>
                        </tr>
                        <tr>
                            <td class="trestab">Retorne <span class="verdelevecodigo">"É par"</span></td>
                        </tr>
                        <tr>
                            <td class="doistab"><span class="amarelocodigo">Senão</span></td>
                        </tr>
                        <tr>
                            <td class="trestab">Retorne <span class="verdelevecodigo">"É impar"</span></td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="verdecodigo">Fim Função</span></td>
                        </tr>
                        <tr>
                            <td></td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="verdecodigo">Escrever</span> (<span class="verdecodigo">par</span>(<span class="roxocodigo">2</span>))</td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="verdecodigo">Escrever</span> (<span class="verdecodigo">par</span>(<span class="roxocodigo">0</span>))</td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="verdecodigo">Escrever</span> (<span class="verdecodigo">par</span>(<span class="roxocodigo">3</span>))</td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="verdecodigo">Escrever</span> (<span class="verdecodigo">par</span>(<span class="roxocodigo">9</span>))</td>
                        </tr>
                        <tr style="background-color: black;">
                            <td class="umtab">É par</td>
                        </tr>
                        <tr style="background-color: black;">
                            <td class="umtab">É par</td>
                        </tr>
                        <tr style="background-color: black;">
                            <td class="umtab">É impar</td>
                        </tr>
                        <tr style="background-color: black;">
                            <td class="umtab">É impar</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <p>A função apresentada irá passar o parâmetro apresentado para um bloco condicional. Se o resto da divisão do parâmetro por 2 for 0, teremos um número par - e retornaremos “É par”. Caso contrário, executaremos o bloco Senão e teremos um retorno “É ímpar”.</p>
            <p>Essa passagem de parâmetros que vimos até agora é conhecida como <strong>passagem de valor</strong>. Podemos ter uma outra forma de passagem de parâmetros chamada de <strong>referência</strong>. Aqui, ao invés de passar uma cópia do valor de uma variável para uma função, é <strong>passada uma referência (ou endereço de memória) para a variável original</strong>. Isso significa<strong> que a função pode modificar o valor da variável original diretamente</strong>, já que ela tem acesso direto à sua localização na memória.</p>
            <p class="destaqueVermelho">Parâmetro por <u>valor</u> > passa um <u>cópia do valor original</u></p>
            <p class="destaqueVermelho">Parâmetro por <u>referência</u> > passa uma <u>referência ao local</u> de armazenamento</p>
            <p>Temos alguns tipos especiais de funções. As princiáis, e que você precisa saber, são:</p>
            <ul>
                <li>Funções recursivas</li>
                <li>Funções anônimas</li>
                <li>Funções de ordem superior</li>
                <li>Funções nominadas</li>
                <li>Funções puras</li>
            </ul>
            <h3>Tipos de Funções</h3>
            <h4>Funções recursivas</h4>
            <p>Pode ser que uma função chame a si mesma durante o a sua execução. Esses casos são chamados de funções recursivas. Esses casos são úteis para cálculos matemáticos complexos, como Fibonacci, navegações de estruturas de dados mais avançadas, algoritmos mais avançados, entre outros.</p>
            <p>Para estruturarmos uma função recursiva, não basta simplesmente chamar a própria função dentro do seu corpo - afinal, se fizermos isso, teremos um loop infinito que “quebrará” o código. Devemos seguir uma estrutura composta de:</p>
            <ul>
                <li>Um<strong> caso base</strong>, literal, que determina quando a função recursiva deve parar de chamar a si mesma e começar a retornar valores. Ela é a parte essencial para que não entremos em um loop infinito.</li>
                <li> Uma <strong>chamada recursiva</strong>, que irá chamar a função principal com um argumento diferente a cada laço. Cada chamada recursiva normalmente reduz o problema em direção ao caso base, garantindo que, eventualmente, o caso base seja alcançado e a recursão pare.</li>
            </ul>
            <div class="tabelaExplica">
                <table>
                    <tbody>
                        <tr>
                            <th colspan="2">Função Recursiva</th>
                        </tr>
                        <tr>
                            <th style="width: 50%;">Caso base</th>
                            <th style="width: 50%;">Chamada recursiva</th>
                        </tr>
                    </tbody>
                </table>
            </div>
            <p>Vou trazer um exemplo para você entender melhor o funcionamento, vamos lá.</p>
            <p><img src="img/funcaorecursiva.png" alt="função recursiva"></p>
            <h4>Funções puras</h4>
            <p>Uma função é chamada de <strong>função pura</strong> se, e somente se, dada uma mesma entrada, sempre <strong>retornará uma mesma saída</strong>, sem <strong>efeitos colaterais observáveis</strong>. Isso quer dizer que o resultado da função depende apenas de seus argumentos, e não de estados externos, como variáveis globais ou estados do sistema.</p>
            <p>Portanto, uma função pura tem 3 características principais:</p>
            <ul>
                <li><strong>Determinismo:</strong> Dadas as mesmas entradas, uma função pura sempre produzirá o mesmo resultado.</li>
                <li><strong>Ausência de efeitos colaterais:</strong> Funções puras não modificam variáveis globais, arquivos, bancos de dados, etc. Seu único efeito é retornar um valor.</li>
                <li><strong>Transparência referencial:</strong> Pode-se substituir a chamada de uma função pura pelo seu resultado, sem alterar o comportamento do programa.</li>
            </ul>
            <h4>Funções nominadas</h4>
            <p>As <strong>funções nominadas</strong>, sem surpresa, são funções com nomes específicos e podem ser chamadas por esse nome, em qualquer parte do programa. Ela é declarada com um nome específico, de forma a permitir sua reutilização ao longo do programa. Até agora, todas as funções que trabalhamos são funções nominadas.</p>
            <p>Existem algumas funções nominadas “especiais”, que já foram pré-concebidas e têm seu nome restrito ao uso por outras funções. Elas trazem funcionalidades pré-programadas, como o print() em Python, que faz uma impressão do código no terminal de comando, ou o length() em JavaScript, que registra o comprimento de um objeto.</p>
            <h4>Funções anônimas</h4>
            <p>Funções anônimas são chamadas assim pois não possuem nome - são um contraponto às funções nominadas. Elas só podem ser utilizadas localmente, já que não possuem uma referência para serem chamadas externamente. O exemplo mais comum de funções anônimas são as funções lambda, em Python.</p>
            <p>Veja um exemplo em pseudocódigo:</p>
            <div class="tabelaEditorCodigo">
                <table>
                    <tbody>
                        <tr class="cabecalhoEditorCodigo">
                            <td class="linhaEditorCodigo">Pseudocódigo</td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="azulcodigo">int</span> Quadrado <span class="rosacodigo">=</span> <span class="verdecodigo">Função</span>(x) retornar x <span class="rosacodigo">*</span> x</td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="azulcodigo">int</span> Resultado <span class="rosacodigo">=</span> <span class="verdecodigo">Quadrado</span>(<span class="roxocodigo">5</span>)</td>
                        </tr>
                        <tr>
                            <td class="umtab"></td>
                        </tr>
                        <tr style="background-color: black;">
                            <td class="umtab">5</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <p>Veja que estamos chamando a variável Quadrado, que especifica uma função local, e não a própria função - até porque ela não tem nome, não temos como chamá-la.</p>
            <h4>Funções de ordem superior</h4>
            <p>Uma função de ordem superior é uma função que recebe outra função como argumento e/ou retorna uma função como resultado. Em outras palavras, uma função de ordem superior trata funções como cidadãos de primeira classe, permitindo que elas sejam passadas e retornadas como qualquer outro tipo de dado. Veja um exemplo:</p>
            <div class="tabelaEditorCodigo">
                <table>
                    <tbody>
                        <tr class="cabecalhoEditorCodigo">
                            <td class="linhaEditorCodigo">Pseudocódigo</td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="verdecodigo">Função operacaoMatematica</span>(x, y, operacao)</td>
                        </tr>
                        <tr>
                            <td class="doistab">retornar <span class="verdecodigo">operacao</span>(x, y)</td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="verdecodigo">fim Função</span></td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <p>A princípio, a função parece uma função simples, apenas com três parâmetros - mas, no corpo dela, dentro do bloco de código, estamos chamando outra função, a função operacao(). Essa função pode ser definida externamente, e passada como parâmetro. Veja como podemos desenvolver esse caso.</p>
            <div class="tabelaEditorCodigo">
                <table>
                    <tbody>
                        <tr class="cabecalhoEditorCodigo">
                            <td class="linhaEditorCodigo">Pseudocódigo</td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="verdecodigo">Função aplicarOperacaoMatematica</span>(x, y, operacao)</td>
                        </tr>
                        <tr>
                            <td class="doistab">retornar <span class="verdecodigo">operacao</span>(x, y)</td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="verdecodigo">fim Função</span></td>
                        </tr>
                        <tr>
                            <td class="umtab"></td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="verdecodigo">Função soma</span>(a, b)</td>
                        </tr>
                        <tr>
                            <td class="doistab">retornar a <span class="rosacodigo">+</span> b</td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="verdecodigo">fim Função</span></td>
                        </tr>
                        <tr>
                            <td class="umtab"></td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="verdecodigo">Função multiplicacao</span>(a, b)</td>
                        </tr>
                        <tr>
                            <td class="doistab">retornar a <span class="rosacodigo">*</span> b</td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="verdecodigo">fim Função</span></td>
                        </tr>
                        <tr>
                            <td class="umtab"></td>
                        </tr>
                        <tr>
                            <td class="umtab"><span>Int</span> resultado1 <span class="rosacodigo">=</span> <span class="verdecodigo">operacaoMatematica</span>(<span class="roxocodigo">5</span>, <span class="roxocodigo">3</span>, soma)</td>
                        </tr>
                        <tr>
                            <td class="umtab"><span>Int</span> resultado2 <span class="rosacodigo">=</span> <span class="verdecodigo">operacaoMatematica</span>(<span class="roxocodigo">5</span>, <span class="roxocodigo">3</span>, multiplicacao)</td>
                        </tr>
                        <tr>
                            <td class="umtab"></td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="verdecodigo">Escrever</span>(resultado1)</td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="verdecodigo">Escrever</span>(resultado2)</td>
                        </tr>
                        <tr style="background-color: black;">
                            <td class="umtab">8</td>
                        </tr>
                        <tr style="background-color: black;">
                            <td class="umtab">15</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </section>

        <section>

            <!-- AULA 01 -->

            <h2>Aula 01 - Métodos de Ordenação e Estruturas de Dados</h2>

            <h3>Métodos de Ordenação</h3>
            <p><strong>Métodos de Ordenação</strong> são algoritmos que têm o objetivo principal de posicionar os elementos de uma estrutura de dados em uma <strong>determinada ordem</strong>. Pois isso possibilita o acesso mais rápido e eficiente aos dados. Existem dezenas de métodos, todavia nessa aula veremos apenas os mais importantes: BubbleSort, QuickSort, InsertionSort, SelectionSort, MergeSort, ShellSort e HeapSort.</p>
            <p><strong>Estabilidade:</strong> Um método estável é aquele em que os itens com chaves iguais mantêm-se com a posição inalterada durante o processo de ordenação, ou seja, preserva-se a ordem relativa dos itens com chaves duplicadas ou iguais. <strong>Métodos Estáveis:</strong> Bubble, Insertion e Merge; <strong>Métodos Instáveis:</strong> Selection, Quick, Heap e Shell. Vejamos um exemplo:</p>
            <p><img src="img/metodo.ordenacao.estaveis.instaveis.png" alt="Método de Ordenacao - Estaveis e Instaveis"></p>
            <p>Na imagem acima, foi colocado um sinal de aspas simples e duplas apenas para diferenciá-los, mas trata-se do mesmo número. Um algoritmo estável ordena todo o restante e não perde tempo trocando as posições de elementos que possuam chaves idênticas. Já um algoritmo instável ordena todos os elementos, inclusive aqueles que possuem chaves idênticas (sob algum outro critério).</p>

            <p><strong>BubbleSort (Troca)</strong></p>
            <p>Nesse método, os elementos da lista são movidos para as posições adequadas de forma contínua.</p>
            <p>Em cada iteração do método, percorremos a lista a partir de seu início comparando cada elemento com seu sucessor, trocando-se de posição se houver necessidade.</p>
            <p>Algoritmo usa o conceito de bolhas subindo até o topo.</p>
            <p>Exemplo de execução:</p>
            <p><img src="img/Bubble-sort.gif" alt="Selection Sort Example" style="max-height: 90vh; border: 3px solid black; padding: 10px; box-sizing: border-box;"></p>
            <p> É possível mostrar que, se a lista tiver n elementos, após no máximo (n-1) iterações, a lista estará em ordem (crescente ou decrescente). Observem abaixo o código para a Ordenação em Bolha:</p>
            <p><img src="img/bubble sort3.png" alt="bubble sort"></p>

            <p><strong>SelectionSort (Seleção)</strong></p>
            <p>Esse algoritmo consiste em selecionar o menor elemento de um vetor e trocá-lo (swap) pelo item que estiver na primeira posição, ou seja, inseri-lo no início do vetor.</p>
            <p>Em cada iteração do método, percorremos a lista a partir de seu início buscando o menor número, comparado todos os números, ele passa o menor número para a primeira posição. Essas duas operações são repetidas com os itens restantes até o último elemento. </p>
            <p>Algoritmo escolhe o menor elemento a cada passada.</p>
            <p>Exemplo de execução:</p>
            <p><img src="img/Selection-Sort-Animation.gif" alt="Selection Sort Example" style="max-height: 90vh; width: auto; border: 3px solid black; padding: 10px; box-sizing: border-box;"></p>
            <p><img src="img/selection.sort3.png" alt="selection sort"></p>

            <p><strong>Insertion Sort</strong></p>
            <p>Esse algoritmo, também conhecido como Inserção Direta, é bastante simples e apresenta um desempenho significativamente melhor que o BubbleSort, em termos absolutos. Além disso, ele é extremamente eficiente para listas que já estejam substancialmente ordenadas e listas com pequeno número de elementos.</p>
            <p>Algoritmo se comporta como cartas sendo organizadas na mão.</p>
            <p>Exemplo de execução:</p>
            <p><img style="border: 3px solid black;" src="img/Insertion-sort-example-300px.gif" alt="Inserction Sort Example"></p>
            <p>É fácil perceber que se a lista possui n elementos, após (n-1) inserções, ela estará ordenada. Para inserir o pivô, percorremos a parte esquerda, da direita para a esquerda, deslocando os elementos estritamente maiores que o pivô uma posição para direita.</p>
            <p><img src="img/insertion.sort4.png" alt="insertion sort"></p>

            <p><strong>ShellSort (Inserção)</strong></p>
            <p>Nesse método, as comparações e as trocas são feitas conforme determinada distância (gap) entre dois elementos, de modo que, se gap = 6, há comparação entre o 1º e 7º elementos ou entre o 2º e 8º elementos e assim sucessivamente, repetindo até que as últimas comparações e trocas tenham sido efetuadas e o gap tenha chegado a 1.</p>
            <p>Algoritmo é uma melhoria do Insertion Sort com saltos.</p>
            <p><img src="img/shell.sort.png" alt="Shell Sort"></p>
            <p><img src="img/shell.sort2.png" alt="Shell Sort"></p>
            <p><img src="img/shell.sort3.png" alt="Shell Sort"></p>

            <p><strong>QuickSort (Troca)</strong></p>
            <p>Neste método, a lista é dividida em parte esquerda e parte direita, sendo que os elementos da parte esquerda são todos menores que os elementos da parte direita. Essa fase do processo é chamada de partição. Em seguida, as duas partes são ordenadas recursivamente (usando o próprio QuickSort).</p>
            <p>Uma estratégia para fazer a partição é escolher um valor como pivô e então colocar na parte esquerda os elementos menores ou iguais ao pivô e na parte direita os elementos maiores que o pivô – galera, a escolha do pivô é crítica! Em geral, utiliza-se como pivô o primeiro elemento da lista, a despeito de existirem maneiras de escolher um “melhor” pivô.</p>
            <p>Algoritmo é o mais rápido na prática e usa pivôs.</p>
            <p>Exemplo de execução:</p>
            <p><img style="border: 3px solid black;" src="img/Merge-sort-example-300px.gif" alt="Merge Sort Example"></p>
            <p>Esse algoritmo é um dos métodos mais rápidos de ordenação, apesar de às vezes partições desequilibradas poderem conduzir a uma ordenação lenta. A eficácia do método depende da escolha do pivô mais adequado ao conjunto de dados que se deseja ordenar. Alguns, por exemplo, utilizam a mediana de três elementos para otimizar o algoritmo.</p>
            <p><img src="img/quick.sort2.png" alt="Quick Sort"></p>

            <p><strong>MergeSort (Intercalação)</strong></p>
            <p>Essa técnica consiste basicamente em decompor a instância a ser resolvida em instâncias menores do mesmo tipo de problema, resolver tais instâncias (em geral, recursivamente) e por fim utilizar as soluções parciais para obter uma solução da instância original.</p>
            <p>Naturalmente, nem todo problema pode ser resolvido através de divisão e conquista. Para que seja viável aplicar essa técnica a um problema, ele deve possuir duas propriedades estruturais. O problema deve ser decomponível, ou seja, deve ser possível decompor qualquer instância não trivial do problema em instâncias menores do mesmo tipo de problema.</p>
            <p>Além disso, deve ser sempre possível utilizar as soluções obtidas com a resolução das instâncias menores para chegar a uma solução da instância original. No MergeSort, divide-se a lista em duas metades. Essas metades são ordenadas recursivamente (usando o próprio MergeSort) e depois são intercaladas. Abaixo segue uma possível solução:</p>
            <p>Algoritmo é o mais eficiente e usa divisão recursiva</p>
            <p>Exemplo de execução:</p>
            <p><img style="border: 3px solid black;" src="img/Merge-sort-example-300px.gif" alt="Heap Sort Example"></p>
            <p><img src="img/merge.sort5.png" alt="Merge Sort"></p>

            <p><strong>Heap Sort</strong></p>
            <p>Esse algoritmo utiliza uma estrutura de dados chamada heap, para ordenar os elementos à medida que os insere na estrutura.</p>
            <p>Essa estrutura pode ser representada como uma árvore ou como um vetor. Entenderam? Inicialmente, insere-se os elementos da lista em um heap.</p>
            <p>Em seguida, fazemos sucessivas remoções do menor elemento do heap, colocando os elementos removidos do heap de volta na lista – a lista estará então em ordem crescente.</p>
            <p>O heapsort é um algoritmo de ordenação em que a sua estrutura auxiliar de armazenamento fora do arranjo de entrada é constante durante toda a sua execução.</p>
            <p>Exemplo de execução:</p>
            <p><img style="border: 3px solid black;" src="img/Heapsort-example.gif" alt="Heap Sort Example"></p>
            <p><img src="img/heap.sort4.png" alt="Heap Sort"></p>
            

            <p></p>
            <div class="tabelaExplica">
                <table>
                    <tbody>
                        <tr>
                            <th colspan="7">Quadro-Resumo Comparativo</th>
                        </tr>
                        <tr>
                            <th>Algoritmo</th>
                            <th>Melhor Caso</th>
                            <th>Médio Caso</th>
                            <th>Pior Caso</th>
                            <th>Estável</th>
                            <th>In-place</th>
                            <th>Palavra-chave</th>
                        </tr>
                        <tr>
                            <td>Bubble Sort</td>
                            <td>O(n)</td>
                            <td>O(n²)</td>
                            <td>O(n²)</td>
                            <td>Sim</td>
                            <td>Sim</td>
                            <td>Bolhas subindo</td>
                        </tr>
                        <tr>
                            <td>Insertion Sort</td>
                            <td>O(n)</td>
                            <td>O(n²)</td>
                            <td>O(n²)</td>
                            <td>Sim</td>
                            <td>Sim</td>
                            <td>Cartas na mão</td>
                        </tr>
                        <tr>
                            <td>Selection Sort</td>
                            <td>O(n²)</td>
                            <td>O(n²)</td>
                            <td>O(n²)</td>
                            <td>Não</td>
                            <td>Sim</td>
                            <td>Seleção do menor</td>
                        </tr>
                        <tr>
                            <td>Merge Sort</td>
                            <td>O(n log n)</td>
                            <td>O(n log n)</td>
                            <td>O(n log n)</td>
                            <td>Sim</td>
                            <td>Não</td>
                            <td>Divide e conquista</td>
                        </tr>
                        <tr>
                            <td>Quick Sort</td>
                            <td>O(n log n)</td>
                            <td>O(n log n)</td>
                            <td>O(n²)</td>
                            <td>Não</td>
                            <td>Sim</td>
                            <td>Pivô esperto</td>
                        </tr>
                        <tr>
                            <td>Heap Sort</td>
                            <td>O(n log n)</td>
                            <td>O(n log n)</td>
                            <td>O(n log n)</td>
                            <td>Não</td>
                            <td>Sim</td>
                            <td>Árvore de prioridades</td>
                        </tr>
                        <tr>
                            <td>Shell Sort</td>
                            <td>O(n log n)</td>
                            <td>Depende</td>
                            <td>O(n²)</td>
                            <td>Não</td>
                            <td>Sim</td>
                            <td>Gap e Redução</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <h3>Complexidade de Algoritmos</h3>
            <p>A complexidade de um algoritmo pode ser avaliada pela quantidade de <strong>operações executadas</strong>, independentemente do computador, linguagem ou compilador usado. Essa medição mostra a <strong>qualidade intrínseca do algoritmo</strong>, e para isso usamos simplificações matemáticas.</p>
            <p><strong>Tipos de Casos:</strong></p>
            <ul>
                <li><strong>Melhor caso:</strong> dados já ordenados (ex: cartas 4, 5, 6, 7, 8) → menos trabalho.</li>
                <li><strong>Pior caso:</strong> dados em ordem inversa (ex: 8, 7, 6, 5, 4) → mais trabalho.</li>
                <li><strong>Caso médio:</strong> dados em ordem aleatória.</li>
            </ul>
            <p><strong>Notação Big-O (ou Notação Assintótica):</strong></p>
            <p>É uma forma de representar o comportamento do algoritmo à medida que o tamanho da entrada (N) aumenta. Ela expressa quantas operações primitivas serão feitas em função desse tamanho.</p>
            <ul>
                <li>Exemplo: somar dois números de n dígitos exige n adições → complexidade O(n).</li>
                <li>Se o algoritmo for O(n²), isso indica que o número de operações cresce proporcionalmente ao quadrado da entrada.</li>
            </ul>
            <p>A Notação Big-O nos ajuda a responder perguntas como:</p>
            <p><em>“Se ordenar 10 mil dados leva 1 segundo, quanto tempo levará para ordenar 1 milhão?”</em></p>
            <p>Sobre o tempo de execução: quanto MAIOR a complexidade, mais LENTO é o algoritmo.</p>
            <p>Ordem do mais rápido para o mais lento:</p>
            <div class="tabelaExplica">
                <table>
                    <tbody>
                        <tr>
                            <th>Notação</th>
                            <th>Crescimento</th>
                            <th>Interpretação Simples</th>
                            <th>Tempo relativo</th>
                        </tr>
                        <tr>
                            <td>O(1)</td>
                            <td>Constante</td>
                            <td>Sempre mesmo tempo</td>
                            <td>🟢 Super rápido</td>
                        </tr>
                        <tr>
                            <td>O(log n)</td>
                            <td>Logarítmico</td>
                            <td>Cresce bem devagar</td>
                            <td>🟢 Muito rápido</td>
                        </tr>
                        <tr>
                            <td>O(n)</td>
                            <td>Linear</td>
                            <td>Proporcional ao tamanho da entrada</td>
                            <td>🟡 Razoável</td>
                        </tr>
                        <tr>
                            <td>O(n log n)</td>
                            <td>Linear-log</td>
                            <td>Um pouco mais que linear</td>
                            <td>🟡 Boa escolha</td>
                        </tr>
                        <tr>
                            <td>O(n²)</td>
                            <td>Quadrática</td>
                            <td>Cresce MUITO com entradas maiores</td>
                            <td>🔴 Lento</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <h3>Estrutura de Dados</h3>

            <p>As estruturas de dados, na maioria dos casos, baseiam-se nos tipos de armazenamento vistos dia a dia, ou seja, nada mais são do que a transformação de uma forma de armazenamento já conhecida e utilizada no mundo real adaptada para o mundo computacional. Por isso, cada tipo de estrutura de dados possui <strong>vantagens e desvantagens</strong> e cada uma tem sua <strong>área de atuação otimizada</strong>.</p>
            <p>Conceito importante: <strong>Dados Homogêneos e Heterogêneos</strong></p>
            <ul>
                <li style="padding: 7px;">Dados Homogêneos:  um tipo básico de dados (Ex: Inteiros)</li>
                <li style="padding: 7px;">Dados Heterogêneos: possuem mais de um tipo básico de dados (Ex: Inteiros + Caracteres)</li>
            </ul>
            <p>Os tipos básicos de dados também são chamados de tipos primitivos.</p>
            <p>Classificação importante: <strong>Estruturas Lineares e Estruturas Não-Lineares</strong></p>
            <ul>
                <li style="padding: 7px;">Estruturas Lineares: são aquelas em que cada elemento pode ter um único predecessor (exceto o primeiro elemento) e um único sucessor (exceto o último elemento).</li>
                <ul>
                    <li style="padding: 7px;">Ex: Listas, Pilhas, Filas, Arranjos, entre outros.</li>
                </ul>
                <li style="padding: 7px;">Estruturas Não-Lineares: são aquelas em que cada elemento pode ter mais de um predecessor e/ou mais de um sucessor.</li>
                <ul>
                    <li style="padding: 7px;">Ex: Árvores, Grafos e Tabelas de Dispersão.</li>
                </ul>
            </ul>
            
            <p><strong>TAD - Tipo Abstrato de Dados</strong></p>
            <p>Os Tipos Abstratos de Dados são simplesmente um modelo para um certo tipo de estrutura de dados. Quando falamos em pilha, estamos falando de um tipo abstrato de dados que tem duas operações com comportamentos bem definidos e conhecidos: push (para inserir elementos na pilha); e pop (para retirar elementos da pilha).</p>
            <p>Um tipo abstrato de dados contém um modelo que contém valores e operações associadas, de forma que essas operações sejam precisamente independentes de uma implementação particular. Em geral, um TAD é especificado por meio de uma especificação algébrica que, em geral, contém três partes: <strong>Especificação Sintática</strong>, <strong>Semântica</strong> e de <strong>Restrições</strong>.</p>
            <ol>
                <li style="padding: 7px;"><strong>Especificação Sintática</strong>: define o nome do tipo, suas operações e o tipo dos argumentos das operações, definindo a assinatura do TAD. A Especificação Semântica descreve propriedades e efeitos das operações de forma independente de uma implementação específica.</li>
                <li style="padding: 7px;"><strong>Semântica</strong>: o nível semântico trata do comportamento de um tipo abstrato de dados; e o nível sintático trata da apresentação de um tipo abstrato de dados. Podemos dizer, então, que o TAD encapsula uma estrutura de dados com características semelhantes – podendo ser formado por outros TADs –, e esconde a efetiva implementação dessa estrutura de quem a manipula.</li>
                <li style="padding: 7px;"><strong>Restrições</strong>: estabelece as condições que devem ser satisfeitas antes e depois da aplicação das operações.</li>
            </ol>

            <p><strong>Lista Encadeada</strong></p>
            <p>Trata-se de uma estrutura de dados dinâmica formada por uma sequência encadeada de elementos chamados nós, que contêm dois campos: <strong>campo de informação</strong> e campo de endereço. O primeiro armazena o real elemento da lista e o segundo contém o endereço do próximo nó da lista.</p>
            <p>O campo do próximo endereço do último nó na lista contém um valor especial, conhecido como <strong>NULL</strong>, que não é um endereço válido. Esse ponteiro nulo é usado para indicar o final de uma lista. Uma lista é chamada Lista Vazia ou Lista Nula caso não tenha nós ou tenha apenas um nó sentinela. O valor do ponteiro externo para esta lista é o ponteiro nulo. Uma lista pode ser inicializada com uma lista vazia.</p>
            <p><img src="img/lista.encadeada.linear.png" alt="Lista Encadeada Linear"></p>
            <p>Suponha que seja feita uma mudança na estrutura de uma lista linear, de modo que o campo próximo no último nó contenha um ponteiro de volta para o primeiro nó, em vez de um ponteiro nulo. Esse tipo de lista é chamado Lista Circular, ou seja, a partir de qualquer ponto, é possível atingir qualquer outro ponto da lista.</p>
            <p><img src="img/lista.encadeada.circular.png" alt="Lista Encadeada Circular"></p>
            <p>Observe que uma Lista Circular não tem um primeiro ou último nó natural. Precisamos, portanto, estabelecer um primeiro e um último nó por convenção. Uma convenção útil é permitir que o ponteiro externo para a lista circular aponte para o último nó, e que o nó seguinte se torne o primeiro nó. Assim podemos incluir ou remover um elemento convenientemente a partir do início ou do final de uma lista.</p>
            <p><img src="img/lista.duplamente.encadeada.png" alt="Lista Duplamente Encadeada"></p>
            <p>Embora uma lista circularmente ligada tenha vantagens sobre uma lista linear, ela ainda apresenta várias deficiências. Não se pode atravessar uma lista desse tipo no sentido contrário nem um nó pode ser eliminado de uma lista circularmente ligada sem se ter um ponteiro para o nó antecessor. Nos casos em que tais recursos são necessários, a estrutura de dados adequada é uma <strong>lista duplamente ligada</strong>.</p>
            <p>Cada nó numa lista desse tipo contém <strong>dois ponteiros</strong>, um para seu <strong>predecessor</strong> e outro para seu <strong>sucessor</strong>. Na realidade, no contexto de listas duplamente ligadas, os termos predecessor e sucessor não fazem sentido porque a lista é totalmente simétrica. As listas duplamente ligadas podem ser lineares ou circulares e podem conter ou não um nó de cabeçalho.</p>
            <p>Podemos considerar os nós numa lista duplamente ligada como consistindo em três campos: um campo info que contém as informações armazenadas no nó, e os campos left e right, que contêm ponteiros para os nós em ambos os lados. Dado um ponteiro para um elemento, pode-se acessar os elementos adjacentes e, dado um ponteiro para o último elemento, pode-se percorrer a lista em <strong>ordem inversa</strong>.</p>
            <p>Existem <strong>cinco</strong> operações básicas sobre uma lista encadeada:</p>
            <ol>
                <li><strong>Criação</strong>, em que se cria a lista na memória; </li>
                <li><strong>Busca</strong>, em que se pesquisa nós na lista;</li>
                <li><strong>Inclusão</strong>, em que se insere novos nós na lista em uma determinada posição;</li>
                <li><strong>Remoção</strong>, em que se elimina um elemento da lista;</li>
                <li><strong>Destruição</strong>, em que se destrói a lista junto com todos os seus nós.</li>
            </ol>

            <p><strong>Pilhas</strong></p>
            <p>A Pilha é um <strong>conjunto ordenado</strong> de itens no qual novos itens podem ser inseridos e eliminados em uma extremidade chamada <strong>topo</strong>. Novos itens podem ser colocados no topo da pilha (tornando-se o novo primeiro elemento) ou os itens que estiverem no topo da pilha poderão ser removidos.</p>
            <p>Também conhecida como <strong>Lista LIFO</strong> (Last In First Out), basta lembrar de uma pilha de pratos esperando para serem lavados, ou seja, o último a entrar é o primeiro a sair. A ordem em que os pratos são retirados da pilha é o oposto da ordem em que eles são colocados sobre a pilha e, como consequência, apenas o prato do topo da pilha está acessível.</p>
            <p><img src="img/pilhas.png" alt="Pilhas"></p>
            <p>As Pilhas oferecem três operações básicas:</p>
            <ol>
                <li>push, que insere um novo elemento no topo da pilha;</li>
                <li>pop, que remove um elemento do topo da pilha;</li>
                <li>top (também conhecida como check), que acessa e consulta o elemento do topo da pilha.</li>
            </ol>

            <p><strong>Filas</strong></p>
            <p>Uma fila é um conjunto <strong>ordenado</strong> de itens a partir do qual podem-se <strong>eliminar</strong> itens numa extremidade (chamada início da fila) e no qual podem-se <strong>inserir</strong> itens na outra extremidade (chamada final da fila). Também conhecida como Lista FIFO (First In First Out), basta lembrar de uma fila de pessoas esperando para serem atendidas em um banco, ou seja, o primeiro a entrar é o primeiro a sair.</p>
            <p>Quando um elemento é colocado na fila, ele ocupa seu lugar no fim da fila, como um aluno recém-chegado que ocupa o final da fileira. O elemento retirado da fila é sempre aquele que está no início da fila, como o aluno que se encontra no começo da fileira e que esperou mais tempo. As Filas possuem <strong>início</strong> (ou cabeça) e <strong>fim</strong> (ou cauda). As operações básicas são <strong>Enqueue</strong> (Enfileirar) e <strong>Dequeue</strong> (Desenfileirar).</p>
            <p><img src="img/filas.png" alt="Filas"></p>

            <p><strong>Árvore</strong></p>
            <p>Uma árvore é uma estrutura de <strong>dados hierárquica</strong> (não-linear) composta por um <strong>conjunto finito</strong> de elementos com um único elemento raiz, com zero ou mais sub-árvores ligadas a esse elemento raiz. Como mostra a imagem abaixo, há uma única raiz, em amarelo. Há também nós folhas, em vermelho e seus pais, em verde. Observem ainda os conceitos de Altura, Grau e Nível de uma árvore.</p>
            <p><img src="img/arvore.conceitos.png" alt="Conceitos Básicos de Árvore"></p>
            <p>O Grau informa a quantidade de filhos de um determinado nó! A Raiz tem Nível 0 (excepcionalmente, alguns autores consideram que tem Nível 1) e o nível de qualquer outro nó na árvore é um nível a mais que o nível de seu pai. Por fim, a Altura é a distância entre a raiz e seu descendente mais afastado.</p>

            <p><strong>Como percorrer uma árvore</strong></p>
            <p>Em uma Árvore de Busca Binária, podemos fazer três percursos: <strong>pré-ordem</strong>, <strong>in-ordem</strong> e <strong>pós-ordem</strong> (esses prefixos são em relação a raiz). É interessante notar que, quando se faz um percurso em ordem em uma árvore binária de busca, os valores dos nós aparecem em ordem crescente. A operação "Percorre" tem como objetivo percorrer a árvore numa dada ordem, enumerando os seus nós.</p>
            <p>Quando um nó é enumerado, diz-se que ele foi <strong>"visitado"</strong>. Vamos ver agora esses três percursos:</p>
            <ul>
                <li><strong>Pré-Ordem</strong> (ou Profundidade): visita a raiz; percorre a subárvore esquerda em pré-ordem; percorre a subárvore direita em pré-ordem.</li>
                <li><strong>In-Ordem</strong> (ou Simétrica): percorre a subárvore esquerda em in-ordem; visita a raiz; percorre a subárvore direita em in-ordem.</li>
                <li><strong>Pós-Ordem:</strong> percorre a subárvore esquerda em pós-ordem; percorre a subárvore direita em pós-ordem; visita a raiz.</li>
            </ul>
            <div class="tabelaExplica">
                <table>
                    <tbody>
                        <tr>
                            <th>pré-ordem</th>
                            <td><span style="color: red;">raiz</span></td>
                            <td><span style="color: blue;">esquerda</span></td>
                            <td><span style="color: green;">direita</span></td>
                        </tr>
                        <tr>
                            <th>ordem</th>
                            <td><span style="color: blue;">esquerda</span></td>
                            <td><span style="color: red;">raiz</span></td>
                            <td><span style="color: green;">direita</span></td>
                        </tr>
                        <tr>
                            <th>pós-ordem</th>
                            <td><span style="color: blue;">esquerda</span></td>
                            <td><span style="color: green;">direita</span></td>
                            <td><span style="color: red;">raiz</span></td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <p><strong>Percorrendo pelas bolinhas</strong></p>
            <ul>
                <li>Pré-ordem: coloca a bolinha à esquerda</li>
                <li>Ordem: coloca a bolinha em baixo</li>
                <li>Pós-ordem: coloca a bolinha à direita</li>
            </ul>
            <p><img src="img/arvore.percorrer.bolinha.png" alt="Percorrer Árvore Bolinhas"></p>

            <h3>Pesquisa de Dados</h3>
            <p>Uma das tarefas de maior importância na computação é a pesquisa de informações contidas em coleções de dados. Em geral, desejamos que essa tarefa seja executada sem que haja a necessidade de inspecionar toda a coleção de dados.</p>

            <p><strong>Busca Sequencial</strong></p>
            <p>Imaginem que eu estou à procura de um valor X em um vetor L[ ]! Para tal, posso inspecionar as posições sequenciais de L[ ] a partir da primeira posição: se eu encontrar X, minha busca tem êxito; se eu alcanço a última posição e não encontro X, concluímos que esse valor não ocorre no vetor L[ ]. Essa busca em que eu inspeciono uma estrutura posição por posição é chamada de <strong>Sequencial ou Linear</strong>.</p>
            <p>Considerando que o vetor L[ ] contém N elementos, ordenados ou não, é fácil verificar que a busca sequencial requer tempo linearmente proporcional ao tamanho do vetor, i.e., da ordem O(n). Por conta disso, é comum dizer que a busca sequencial é uma Busca Linear. Entenderam? Quanto maior o vetor, maior o tempo em média para buscar um elemento! Quanto mais ao final, mais demorado.</p>
            <p>A <strong>Busca Sequencial</strong> é muito lenta para grandes quantidades de dados, mas aceitável para listas pequenas e que mudam constantemente. Observa-se que no Melhor Caso, X está na primeira posição, logo necessita apenas de uma comparação; no Pior Caso, X está na última posição, logo necessita de N comparações; e no Caso Médio, X é encontrado após (n+1)/2 comparações.</p>

            <p><strong>Busca Binária</strong></p>
            <p>A Busca Binária é um algoritmo de busca em vetores que segue o paradigma de divisão-e-conquista. Partese do pressuposto de que o vetor está ordenado e realiza sucessivas divisões do espaço de busca, comparando o elemento chave com o elemento do meio do vetor.</p>
            <p>Quando o Vetor L[ ] estiver em ordem crescente, podemos determinar se X ocorre em L[ ] de forma mais rápida da seguinte forma: inspeciona-se a posição central do vetor! Se essa posição já contiver X, a busca para! Por que, professor? Porque nós já encontramos X! Se X for menor que esse elemento central, passamos a procurar X, recursivamente, no intervalo de L[ ] que se encontra à esquerda da posição central.</p>
            <p>Se X for maior do que o elemento central, continuamos a procurar X, recursivamente, no intervalo de L que está à direita da posição central. Se o intervalo se tornar vazio, a busca para, tendo sido malsucedida. Esse procedimento é conhecido como Busca Binária e, facilmente, pode-se adaptar a busca em ordem decrescente.</p>





        </section>


        <section>

            <!-- AULA 03-->
    
            <h2>Aula 03 - DevOps</h2>

            <h3>O que é DevOps?</h3>
            <p><strong>DevOps</strong> é uma <strong>cultura organizacional</strong> e também um <strong>conjunto de práticas</strong> que unem <strong>Desenvolvimento (Dev)</strong> e <strong>Operações (Ops)</strong>.</p>
            <p>O objetivo é entregar software de forma <strong>rápida, contínua, com qualidade e segurança</strong>, reduzindo falhas e aumentando a colaboração entre as equipes.</p>
            <p>Tradicionalmente, desenvolvimento e operações trabalhavam em <strong>silos separados</strong>: um grupo criava o software e outro cuidava da infraestrutura. Isso causava atrasos, retrabalho e falhas de comunicação. O <strong>DevOps quebra essa barreira</strong>, integrando os times desde o planejamento até a manutenção em produção.</p>
            <p><strong>Características principais do DevOps:</strong></p>
            <ul>
                <li><strong>Automação</strong> de processos (build, testes, deploy, monitoramento).</li>
                <li><strong>Colaboração</strong> entre equipes multidisciplinares.</li>
                <li><strong>Feedback contínuo</strong> para melhoria.</li>
                <li><strong>Integração e entrega contínuas (CI/CD)</strong>.</li>
            </ul>

            <h3>Princípios Fundamentais do DevOps</h3>
            <ol>
                <li><strong>Processo repetível e confiável</strong> – a entrega não deve ser traumática, mas previsível.</li>
                <li><strong>Automatizar tudo</strong> – menos erros humanos, mais agilidade.</li>
                <li><strong>Controle de versão único</strong> – código, configuração e documentação devem estar versionados.</li>
                <li><strong>Resolver cedo</strong> – se algo dá problema, execute com frequência até estabilizar.</li>
                <li><strong>“Concluído” significa pronto para produção</strong> – só é considerado concluído se estiver testado e documentado.</li>
                <li><strong>Responsabilidade compartilhada</strong> – todos (Dev + Ops) são responsáveis pelo sucesso da entrega.</li>
            </ol>

            <h3>Ciclo de Vida do DevOps</h3>
            <p>O ciclo DevOps é contínuo e interligado:</p>
            <ol>
                <li><strong>Discover / Plan (Descoberta / Planejamento)</strong> – entender requisitos e planejar.</li>
                <li><strong>Code (Codificação)</strong> – desenvolvimento do software.</li>
                <li><strong>Build (Construção)</strong> – compilação e empacotamento automatizados.</li>
                <li><strong>Test (Teste)</strong> – verificação automática de qualidade (unitários, integração, aceitação).</li>
                <li><strong>Release (Lançamento)</strong> – preparar para disponibilização controlada.</li>
                <li><strong>Deploy (Implantação)</strong> – instalação em produção, preferencialmente automatizada.</li>
                <li><strong>Operate (Operação)</strong> – manutenção do sistema em uso.</li>
                <li><strong>Monitor (Monitoramento)</strong> – acompanhar desempenho, falhas e segurança.</li>
            </ol>
            <p>Diferencial: <strong>feedback contínuo em todas as fases</strong>, para corrigir rápido.</p>

            <h3>CI/CD (Continuous Integration / Continuous Delivery / Continuous Deployment)</h3>
            <h4>Continuous Integration (CI) – Integração Contínua</h4>
            <p>Cada alteração de código é integrada rapidamente ao repositório principal. Isso evita conflitos e garante testes constantes.</p>
            <p>👉 Mantemos “CI” porque é como aparece em ferramentas (Jenkins CI, GitLab CI).</p>
            <h4>Continuous Delivery (CD) – Entrega Contínua</h4>
            <p>O software está <strong>sempre pronto para ser lançado</strong>, mas a liberação depende de aprovação manual (gerente, equipe de release).</p>
            <p>👉 Banca usa Continuous Delivery porque é o termo da documentação oficial.</p>
            <h4>Continuous Deployment (CD) – Implantação Contínua</h4>
            <p>Cada alteração aprovada vai <strong>direto para produção</strong>, sem intervenção humana.</p>
            <p>👉 Mesmo em português, aparece quase sempre como Continuous Deployment ou “Deploy Contínuo”.</p>
            <p><strong>Benefícios do CI/CD:</strong></p>
            <ul>
                <li>Releases frequentes e confiáveis.</li>
                <li>Feedback rápido para os devs.</li>
                <li>Menos falhas em produção.</li>
                <li>Possibilidade de testar hipóteses com usuários.</li>
            </ul>

            <h3>Ferramentas de DevOps</h3>
            <p>As ferramentas <strong>automatizam</strong> e dão suporte às práticas de DevOps. Nas provas, caem <strong>mais pelo conceito e categoria</strong> do que pelo detalhe.</p>
            
            <h4>Version Control (Controle de Versão)</h4>
            <p>Armazena e gerencia mudanças no código.</p>
            <p>Exemplos: <strong>Git</strong>, <strong>GitHub</strong>, <strong>GitLab</strong>, <strong>Bitbucket</strong>.</p>
            <p>👉 Termo mantido porque ferramentas e provas usam “Version Control”.</p>

            <h4>CI/CD (Integração e Entrega Contínuas)</h4>
            <p>Automatizam build, testes e deploy.</p>
            <p>Exemplos: <strong>Jenkins</strong>, <strong>GitLab CI</strong>, <strong>GitHub Actions</strong>, <strong>Codeship</strong>.</p>

            <h4>IaC – Infrastructure as Code (Infraestrutura como Código)</h4>
            <p>Gerenciar servidores e configurações via código, evitando erros manuais.</p>
            <p>Exemplos: <strong>Ansible</strong>, <strong>Terraform</strong>, <strong>Puppet</strong>, <strong>Chef</strong>.</p>
            <p>👉 “IaC” é padrão internacional, aparece assim em provas.</p>

            <h4>Containerization (Containerização) e Orchestration (Orquestração)</h4>
            <p>Permitem empacotar e escalar aplicações em ambientes isolados.</p>
            <p>Exemplos: <strong>Docker (contêineres)</strong>, <strong>Kubernetes (orquestração de contêineres)</strong>.</p>

            <h4>Monitoring (Monitoramento) e Logging (Registro de Logs)</h4>
            <p>Acompanham desempenho, falhas e segurança.</p>
            <p>Exemplos: <strong>Prometheus</strong>, <strong>Grafana</strong>, <strong>Nagios</strong>, <strong>Loggly</strong>, <strong>Graylog</strong>.</p>
            <p>👉 Termos usados em inglês porque dashboards e documentação trazem assim.</p>

            <h4>Collaboration (Colaboração)</h4>
            <p>Ferramentas para comunicação e gestão de tarefas.</p>
            <p>Exemplos: <strong>Jira</strong>, <strong>Trello</strong>, <strong>Slack</strong>, <strong>Microsoft Teams</strong>.</p>

            <h3>Benefícios do DevOps</h3>
            <ul>
                <li>Redução do tempo de entrega (time-to-market).</li>
                <li>Maior confiabilidade em produção.</li>
                <li>Detecção e correção rápida de falhas.</li>
                <li>Equipes mais colaborativas.</li>
                <li>Software mais alinhado às necessidades do cliente.</li>
            </ul>

            <p><strong>Ciclo de DevOps</strong></p>
            <p style="text-align: center;"><img src="img/devops.ciclo.png" alt="DevOps Ciclo" width="95%"></p>

            <p><strong>Ferramentas de DevOps</strong></p>
            <p style="text-align: center;"><img src="img/devops.ferramentas.png" alt="DevOps Ferramentas" width="95%"></p>

        </section>

        <section>

            <!-- AULA 06 - Python-->

            <h2>Aula 06 – Python</h1>

            <h3>O que é Python?</h3>
            <p>Python é uma linguagem de programação <strong>interpretada</strong>, <strong>de alto nível</strong>, <strong>dinâmica</strong> e <strong>multiplataforma</strong>. 
            Foi criada para ser <em>simples de ler e escrever</em>, sem perder o poder de resolver problemas complexos. 
            É usada em várias áreas: <strong>desenvolvimento web, automação, ciência de dados, inteligência artificial, análise de dados e DevOps</strong>.</p>

            <h3>Principais Características</h3>

            <p><strong>1. Linguagem de Alto Nível</strong></p>
            <p>Sintaxe próxima da linguagem humana. O programador não precisa lidar com detalhes da máquina.</p>

            <p><strong>2. Interpretada</strong></p>
            <p>O código é executado <strong>linha por linha</strong> pelo interpretador, sem necessidade de compilação prévia.</p>

            <p><strong>3. Multiparadigma</strong></p>
            <p>Python suporta diferentes estilos de programação:</p>
            <ul>
                <li>Orientada a Objetos (OOP)</li>
                <li>Funcional</li>
                <li>Imperativa/Procedural</li>
            </ul>

            <p><strong>4. Orientada a Objetos</strong></p>
            <p>Tudo em Python é um objeto. Suporta classes, herança e polimorfismo:</p>
            <div class="tabelaEditorCodigo">
                <table>
                <tbody>
                    <tr class="cabecalhoEditorCodigo">
                    <td class="linhaEditorCodigo">Python</td>
                    </tr>
                    <tr>
                    <td class="umtab"><span class="amarelocodigo">class</span> Pessoa<span class="rosacodigo">:</span></td>
                    </tr>
                    <tr>
                    <td class="doistab"><span class="amarelocodigo">def</span> __init__(self, nome)<span class="rosacodigo">:</span></td>
                    </tr>
                    <tr>
                    <td class="trestab">self.nome <span class="rosacodigo">=</span> nome</td>
                    </tr>
                    <tr>
                    <td class="umtab">p <span class="rosacodigo">=</span> Pessoa(<span class="verdelevecodigo">"Ana"</span>)</td>
                    </tr>
                    <tr>
                    <td class="umtab"><span class="verdecodigo">print</span>(p.nome)</td>
                    </tr>
                </tbody>
                </table>
            </div>

            <p><strong>5. Tipagem Forte e Dinâmica</strong></p>
            <p><strong>Forte:</strong> não permite misturar tipos incompatíveis.</p>
            <div class="tabelaEditorCodigo">
                <table>
                <tbody>
                    <tr class="cabecalhoEditorCodigo">
                    <td class="linhaEditorCodigo">Python</td>
                    </tr>
                    <tr>
                    <td class="umtab"><span class="verdecodigo">print</span>(<span class="verdelevecodigo">"5"</span> <span class="rosacodigo">+</span> <span class="roxocodigo">3</span>)  <span class="verdecodigo"># ERRO</span></td>
                    </tr>
                </tbody>
                </table>
            </div>

            <p><strong>Dinâmica:</strong> não precisa declarar tipo, ele é atribuído em tempo de execução.</p>
            <div class="tabelaEditorCodigo">
                <table>
                <tbody>
                    <tr class="cabecalhoEditorCodigo">
                    <td class="linhaEditorCodigo">Python</td>
                    </tr>
                    <tr>
                    <td class="umtab">x <span class="rosacodigo">=</span> <span class="roxocodigo">10</span> <span class="verdecodigo"># int</span></td>
                    </tr>
                    <tr>
                    <td class="umtab">x <span class="rosacodigo">=</span> <span class="verdelevecodigo">"dez"</span> <span class="verdecodigo"># agora é str</span></td>
                    </tr>
                </tbody>
                </table>
            </div>
            <p>Importante: A função input() sempre retorna uma string (str), independentemente do que o usuário digite.</p>

            <p><strong>6. Portável / Multiplataforma</strong></p>
            <p>O mesmo código roda em Windows, Linux, macOS e outros sistemas.</p>

            <p><strong>7. Sintaxe Simples</strong></p>
            <p>Usa indentação (espaços) para definir blocos de código:</p>
            <div class="tabelaEditorCodigo">
                <table>
                <tbody>
                    <tr class="cabecalhoEditorCodigo">
                    <td class="linhaEditorCodigo">Python</td>
                    </tr>
                    <tr>
                    <td class="umtab"><span class="amarelocodigo">if</span> <span class="roxocodigo">5</span> <span class="rosacodigo">&#62;</span> <span class="roxocodigo">2</span><span class="rosacodigo">:</span></td>
                    </tr>
                    <tr>
                    <td class="doistab"><span class="verdecodigo">print</span>(<span class="verdelevecodigo">"Cinco é maior que dois"</span>)</td>
                    </tr>
                </tbody>
                </table>
            </div>

            <p><strong>8. Biblioteca Padrão Rica</strong></p>
            <p>Inclui módulos para arquivos, redes, data/hora, matemática, expressões regulares e muito mais.</p>

            <p><strong>9. Gerenciamento Automático de Memória</strong></p>
            <p>Possui <em>garbage collector</em> que libera memória automaticamente.</p>

            <p><strong>10. Comunidade e Open Source</strong></p>
            <p>Python é gratuito, de código aberto e possui milhares de pacotes disponíveis no <strong>PyPI</strong>.</p>

            <h3>🧾 Estruturas Básicas</h3>

            <h4>Variáveis</h4>
            <p>Variáveis são contêineres para armazenar valores de dados. Python não tem comando para declarar uma variável. Em Python, as variáveis são criadas quando você atribui um valor a ela:</p>
            <div class="tabelaEditorCodigo">
                <table>
                <tbody>
                    <tr class="cabecalhoEditorCodigo">
                    <td class="linhaEditorCodigo">Python</td>
                    </tr>
                    <tr>
                    <td class="umtab">x <span class="rosacodigo">=</span> <span class="roxocodigo">5</span></td>
                    </tr>
                    <tr>
                    <td class="umtab">y <span class="rosacodigo">=</span> <span class="verdelevecodigo">"Olá, Mundo!"</span></td>
                    </tr>
                </tbody>
                </table>
            </div>

            <p>Regras para nomes de variáveis:</p>
            <ul>
                <li>Deve começar com uma letra ou o caractere sublinhado</li>
                <li>Não pode começar com um número</li>
                <li>Pode conter apenas caracteres alfanuméricos e sublinhados (AZ, 0-9, E_)</li>
                <li>Diferenciam maiúsculas de minúsculas</li>
            </ul>

            <h4>Tipos de dados</h4>

            <div class="tabelaExplica">
                <table>
                    <tbody>
                        <tr>
                            <th>Tipo de Dado</th>
                            <th>Descrição</th>
                            <th>Exemplo</th>
                        </tr>
                        <tr>
                            <th>Texto</th>
                            <td>str</td>
                            <td>x = "Hello World"</td>
                        </tr>
                        <tr>
                            <th>Numéricos</th>
                            <td>int, float, complex</td>
                            <td>int: x= "20"<br>float: x = 20.5<br>complex: x = 1j</td>
                        </tr>
                        <tr>
                            <th>Sequência</th>
                            <td>list, tupla, range</td>
                            <td>List: x = ["maçã", "banana", "cereja"]<br>Tupla: x = ("maçã", "banana", "cereja")<br>Range: x = range(6)</td>
                        </tr>
                        <tr>
                            <th>Mapeamento</th>
                            <td>dict</td>
                            <td>Dict: x = {"nomw=e" : "John", "idade" : 36}</td>
                        </tr>
                        <tr>
                            <th>Conjunto</th>
                            <td>set, frozenset</td>
                            <td>Set: x = {"maçã", "banana", "cereja"}<br>Frozenset: x = frozenset({"maçã", "banana", "cereja"})</td>
                        </tr>
                        <tr>
                            <th>Booleano</th>
                            <td>bool</td>
                            <td>x = True<br>y = False</td>
                        </tr>
                        <tr>
                            <th>Binário</th>
                            <td>bytes, bytearray, memoryview</td>
                            <td>Bytes: x = b"Hello"<br>Bytearray: x = bytearray(5)<br>Memoryview: x = memoryview(bytes(5))</td>
                        </tr>
                        <tr>
                            <th>Nenhum tipo</th>
                            <td>NoneType</td>
                            <td>NoneType x = None</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <h3>String em Python</h3>
            <p>
                Como muitas outras linguagens de programação populares, strings em Python são arrays de bytes que representam caracteres unicode. 
                No entanto, o Python não possui um tipo de dado de caractere, um único caractere é simplesmente uma string com comprimento 1. 
                Colchetes podem ser usados para acessar elementos da string.
            </p>

            <p>Como muitas outras linguagens de programação populares, <strong>strings</strong> em Python são <strong>arrays de bytes</strong> que <strong>representam caracteres unicode</strong>. No entanto, o <strong>Python não possui um tipo de dado de caractere</strong>, um único caractere é simplesmente uma string com comprimento 1. Colchetes podem ser usados para acessar elementos da string.
            </p>

            <div class="tabelaEditorCodigo">
                <table>
                    <tbody>
                        <tr class="cabecalhoEditorCodigo">
                            <td class="linhaEditorCodigo">Python</td>
                        </tr>
                        <tr>
                            <td class="umtab">
                                <span class="azulcodigo">a</span> <span class="rosacodigo">=</span> "Hello, World!"<br>
                                <span class="verdecodigo">print</span>(a[1])
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <p>No exemplo, o resultado será “e” porque o array inicia em 0 (zero).</p>

            <p>
                Como strings são arrays, podemos fazer um loop pelos caracteres em uma string com um loop for.
            </p>

            <div class="tabelaEditorCodigo">
                <table>
                    <tbody>
                        <tr class="cabecalhoEditorCodigo">
                            <td class="linhaEditorCodigo">Python</td>
                        </tr>
                        <tr>
                            <td class="umtab">
                                <span class="azulcodigo">for</span> x <span class="azulcodigo">in</span> "banana":<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;<span class="verdecodigo">print</span>(x)
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <p>Para obter o comprimento de uma string, use a função len().</p>

            <div class="tabelaEditorCodigo">
                <table>
                    <tbody>
                        <tr class="cabecalhoEditorCodigo">
                            <td class="linhaEditorCodigo">Python</td>
                        </tr>
                        <tr>
                            <td class="umtab">
                                a <span class="rosacodigo">=</span> "Hello, World!"<br>
                                <span class="verdecodigo">print</span>(<span class="azulcodigo">len</span>(a))
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <p>
                Para verificar se uma determinada palavra ou caractere está presente em uma string, podemos usar a palavra-chave 
                in.
            </p>

            <div class="tabelaEditorCodigo">
                <table>
                    <tbody>
                        <tr class="cabecalhoEditorCodigo">
                            <td class="linhaEditorCodigo">Python</td>
                        </tr>
                        <tr>
                            <td class="umtab">
                                txt <span class="rosacodigo">=</span> "Estratégia Concursos é referência na preparação de alunos "<br>
                                <span class="verdecodigo">print</span>("Concursos" <span class="azulcodigo">in</span> txt)
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <p>É possível procurar uma palavra dentro de uma instrução if:</p>

            <div class="tabelaEditorCodigo">
                <table>
                    <tbody>
                        <tr class="cabecalhoEditorCodigo">
                            <td class="linhaEditorCodigo">Python</td>
                        </tr>
                        <tr>
                            <td class="umtab">
                                txt <span class="rosacodigo">=</span> "Estratégia Concursos é referência na preparação de alunos "<br>
                                <span class="azulcodigo">if</span> "Estratégia" <span class="azulcodigo">in</span> txt:<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;<span class="verdecodigo">print</span>("Sim!, Estratégia está presente no texto.")
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <p>
                Há muitas funções que podem ser utilizadas em strings. Uma delas é o <strong>slice</strong>, que retorna um 
                intervalo de caracteres usando a sintaxe de fatiamento [início:fim].
            </p>

            <div class="tabelaEditorCodigo">
                <table>
                    <tbody>
                        <tr class="cabecalhoEditorCodigo">
                            <td class="linhaEditorCodigo">Python</td>
                        </tr>
                        <tr>
                            <td class="umtab">
                                b <span class="rosacodigo">=</span> "Estratégia Concursos!"<br>
                                <span class="verdecodigo">print</span>(b[2:5])
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <p>O exemplo acima retorna “tra”. O índice final é <em>não-inclusivo</em>, ou seja, o caractere de b[5] não é retornado.</p>

            <p>Ao omitir o índice inicial, o intervalo começará no primeiro caractere:</p>

            <div class="tabelaEditorCodigo">
                <table>
                    <tbody>
                        <tr class="cabecalhoEditorCodigo">
                            <td class="linhaEditorCodigo">Python</td>
                        </tr>
                        <tr>
                            <td class="umtab">
                                b <span class="rosacodigo">=</span> "Estratégia Concursos!"<br>
                                <span class="verdecodigo">print</span>(b[:10])
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <p>Esse exemplo retorna apenas o texto "Estratégia".</p>

            <p>Já ao omitir o índice final, o intervalo vai até o final da string:</p>

            <div class="tabelaEditorCodigo">
                <table>
                    <tbody>
                        <tr class="cabecalhoEditorCodigo">
                            <td class="linhaEditorCodigo">Python</td>
                        </tr>
                        <tr>
                            <td class="umtab">
                                b <span class="rosacodigo">=</span> "Estratégia Concursos!"<br>
                                <span class="verdecodigo">print</span>(b[11:])
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <p>Esse exemplo retorna apenas " Concursos!".</p>

            <p>Também é possível usar índices negativos para iniciar o corte a partir do final da string:</p>

            <div class="tabelaEditorCodigo">
                <table>
                    <tbody>
                        <tr class="cabecalhoEditorCodigo">
                            <td class="linhaEditorCodigo">Python</td>
                        </tr>
                        <tr>
                            <td class="umtab">
                                b <span class="rosacodigo">=</span> "Estratégia Concursos!"<br>
                                <span class="verdecodigo">print</span>(b[-10])
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <p>O exemplo acima retorna apenas o caractere "C".</p>

            <div class="tabelaExplica">
                <table>
                    <tbody>
                        <tr>
                            <th>Métodos para modificar strings</th>
                            <th>Descrição</th>
                        </tr>
                        <tr>
                            <th>upper()</th>
                            <td>Retorna a string em maiúsculas</td>
                        </tr>
                        <tr>
                            <th>lower()</th>
                            <td>Retorna a string em minúsculas</td>
                        </tr>
                        <tr>
                            <th>strip()</th>
                            <td>Remove qualquer espaço em branco do início ou do fim</td>
                        </tr>
                        <tr>
                            <th>replace()</th>
                            <td>Substitui uma string por outra string. Ex: replace("h", "j")</td>
                        </tr>
                        <tr>
                            <th>split()</th>
                            <td>Retorna uma lista em que o texto entre o separador especificado se torna os itens da lista.</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <h4>Operadores em Python</h4>

            <div class="tabelaExplica">
                <table>
                    <tbody>
                        <tr>
                            <th colspan="3">Operadores aritméticos Python</th>
                        </tr>
                        <tr>
                            <th>+</th>
                            <td>Adição</td>
                            <td>x + y</td>
                        </tr>
                        <tr>
                            <th>-</th>
                            <td>Subtração</td>
                            <td>x - y</td>
                        </tr>
                        <tr>
                            <th>*</th>
                            <td>Multiplicação</td>
                            <td>x * y</td>
                        </tr>
                        <tr>
                            <th>/</th>
                            <td>Divisão</td>
                            <td>x / y</td>
                        </tr>
                        <tr>
                            <th>%</th>
                            <td>Módulo</td>
                            <td>x % y</td>
                        </tr>
                        <tr>
                            <th>**</th>
                            <td>Exponenciação</td>
                            <td>x ** y</td>
                        </tr>
                        <tr>
                            <th>//</th>
                            <td>Divisão inteira</td>
                            <td>x // y</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <p>Os operadores de atribuição são usados para atribuir valores a variáveis:</p>

            <div class="tabelaExplica">
                <table>
                    <tbody>
                        <tr>
                            <th>Função</th>
                            <th>Descrição</th>
                            <th>Igual a</th>
                        </tr>
                        <tr>
                            <th>=</th>
                            <td>x = 5</td>
                            <td>x = 5</td>
                        </tr>
                        <tr>
                            <th>+=</th>
                            <td>x += 3</td>
                            <td>x = x + 3</td>
                        </tr>
                        <tr>
                            <th>-=</th>
                            <td>x -= 3</td>
                            <td>x = x - 3</td>
                        </tr>
                        <tr>
                            <th>*=</th>
                            <td>x *= 3</td>
                            <td>x = x * 3</td>
                        </tr>
                        <tr>
                            <th>/=</th>
                            <td>x /= 3</td>
                            <td>x = x / 3</td>
                        </tr>
                        <tr>
                            <th>%=</th>
                            <td>x %= 3</td>
                            <td>x = x % 3</td>
                        </tr>
                        <tr>
                            <th>//=</th>
                            <td>x //= 3</td>
                            <td>x = x // 3</td>
                        </tr>
                        <tr>
                            <th>**=</th>
                            <td>x **= 3</td>
                            <td>x = x ** 3</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <p>Os operadores de comparação são usados para comparar dois valores:</p>

            <div class="tabelaExplica">
                <table>
                    <tbody>
                        <tr>
                            <th>Função</th>
                            <th>Descrição</th>
                            <th>Igual a</th>
                        </tr>
                        <tr>
                            <th>==</th>
                            <td>Igual</td>
                            <td>x == y</td>
                        </tr>
                        <tr>
                            <th>!=</th>
                            <td>Diferente</td>
                            <td>x != y</td>
                        </tr>
                        <tr>
                            <th>></th>
                            <td>Maior que</td>
                            <td>x > y</td>
                        </tr>
                        <tr>
                            <th><</th>
                            <td>Menor que</td>
                            <td>x < y</td>
                        </tr>
                        <tr>
                            <th>>=</th>
                            <td>Maior ou igual a</td>
                            <td>x >= y</td>
                        </tr>
                        <tr>
                            <th><=</th>
                            <td>Menor ou igual a</td>
                            <td>x <= y</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <p>Os operadores lógicos são usados para combinar instruções condicionais:</p>

            <div class="tabelaExplica">
                <table>
                    <tbody>
                        <tr>
                            <th>Operador</th>
                            <th>Descrição</th>
                            <th>Exemplo</th>
                        </tr>
                        <tr>
                            <th>and</th>
                            <td>Retorna True se ambas as declarações forem verdadeiras</td>
                            <td>x < 5 and x < 10</td>
                        </tr>
                        <tr>
                            <th>or</th>
                            <td>Retorna True se uma das declarações for verdadeira</td>
                            <td>x < 5 or x < 4</td>
                        </tr>
                        <tr>
                            <th>not</th>
                            <td>Inverte o resultado, retorna False se o resultado for verdadeiro</td>
                            <td>not(x < 5 and x < 10)</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <p>Os operadores de identidade são usados para comparar os objetos, não se forem iguais, mas <strong>se forem realmente o mesmo objeto</strong>, com a <strong>mesma localização de memória:</strong></p>

            <div class="tabelaExplica">
                <table>
                    <tbody>
                        <tr>
                            <th>Operador</th>
                            <th>Descrição</th>
                            <th>Exemplo</th>
                        </tr>
                        <tr>
                            <th>is</th>
                            <td>Retorna True se ambas as variáveis forem o mesmo objeto</td>
                            <td>x is y</td>
                        </tr>
                        <tr>
                            <th>is not</th>
                            <td>Retorna True se ambas as variáveis não forem o mesmo objeto</td>
                            <td>x is not y</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <p>Os operadores de associação são usados para testar se uma sequência é apresentada em um objeto:</p>

            <div class="tabelaExplica">
                <table>
                    <tbody>
                        <tr>
                            <th>Operador</th>
                            <th>Descrição</th>
                            <th>Exemplo</th>
                        </tr>
                        <tr>
                            <th>in</th>
                            <td>Retorna True se uma sequência com o valor especificado estiver presente no objeto</td>
                            <td>x in y</td>
                        </tr>
                        <tr>
                            <th>not in</th>
                            <td>Retorna True se uma sequência com o valor especificado não estiver presente no objeto</td>
                            <td>x not in y</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <h3>Coleções em Python</h3>

            <h4>Listas</h4>

            <p>
                As listas são usadas para armazenar vários itens em uma única variável. São um dos 4 tipos de dados internos do Python usados para armazenar coleções de dados. As listas são criadas usando colchetes:
            </p>

            <div class="tabelaEditorCodigo">
                <table>
                    <tbody>
                        <tr class="cabecalhoEditorCodigo"><td class="linhaEditorCodigo">Python</td></tr>
                        <tr>
                            <td class="umtab">
                                lista1 <span class="rosacodigo">=</span> ["maçã", "banana", "cereja"]<br>
                                <span class="verdecodigo">print</span>(lista1)
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <p>
                Os itens da lista são ordenados, alteráveis e permitem valores duplicados.
                O primeiro item possui índice [0], o segundo [1], e assim por diante.
            </p>

            <p>
                A lista é mutável, ou seja, podemos alterar, adicionar e remover itens após sua criação.
                Como são indexadas, listas podem conter itens com o mesmo valor:
            </p>

            <div class="tabelaEditorCodigo">
                <table>
                    <tbody>
                        <tr class="cabecalhoEditorCodigo"><td class="linhaEditorCodigo">Python</td></tr>
                        <tr>
                            <td class="umtab">
                                lista2 <span class="rosacodigo">=</span> ["maçã", "banana", "cereja", "maçã", "cereja"]<br>
                                <span class="verdecodigo">print</span>(lista2)
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <p>
                Para determinar quantos itens uma lista possui, use a função len():
            </p>

            <div class="tabelaEditorCodigo">
                <table>
                    <tbody>
                        <tr class="cabecalhoEditorCodigo"><td class="linhaEditorCodigo">Python</td></tr>
                        <tr>
                            <td class="umtab">
                                lista3 <span class="rosacodigo">=</span> ["maçã", "banana", "cereja"]<br>
                                <span class="verdecodigo">print</span>(<span class="azulcodigo">len</span>(lista3))
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <p>
                Os itens da lista podem ser de qualquer tipo de dados:
            </p>

            <div class="tabelaEditorCodigo">
                <table>
                    <tbody>
                        <tr class="cabecalhoEditorCodigo"><td class="linhaEditorCodigo">Python</td></tr>
                        <tr>
                            <td class="umtab">
                                lista1 <span class="rosacodigo">=</span> ["maçã", "banana", "cereja"]<br>
                                lista2 <span class="rosacodigo">=</span> [1, 5, 7, 9, 3]<br>
                                lista3 <span class="rosacodigo">=</span> [True, False, False]
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <p>
                Uma lista pode conter diferentes tipos de dados:
            </p>

            <div class="tabelaEditorCodigo">
                <table>
                    <tbody>
                        <tr class="cabecalhoEditorCodigo"><td class="linhaEditorCodigo">Python</td></tr>
                        <tr>
                            <td class="umtab">
                                lista1 <span class="rosacodigo">=</span> ["abc", 34, True, 40, "masculino"]
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <p>
                Os itens da lista podem ser acessados pelos índices:
            </p>

            <div class="tabelaEditorCodigo">
                <table>
                    <tbody>
                        <tr class="cabecalhoEditorCodigo"><td class="linhaEditorCodigo">Python</td></tr>
                        <tr>
                            <td class="umtab">
                                lista1 <span class="rosacodigo">=</span> ["maçã", "banana", "cereja"]<br>
                                <span class="verdecodigo">print</span>(lista1[1]) <span class="cinzacodigo"># imprime "banana"</span>
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <p>
                A indexação negativa começa pelo fim: -1 é o último item, -2 o penúltimo, etc.
            </p>

            <div class="tabelaEditorCodigo">
                <table>
                    <tbody>
                        <tr class="cabecalhoEditorCodigo"><td class="linhaEditorCodigo">Python</td></tr>
                        <tr>
                            <td class="umtab">
                                lista1 <span class="rosacodigo">=</span> ["maçã", "banana", "cereja"]<br>
                                <span class="verdecodigo">print</span>(lista1[-1]) <span class="cinzacodigo"># imprime "cereja"</span>
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <p>
                Podemos especificar intervalos de índices para retornar uma sublista:
            </p>

            <div class="tabelaEditorCodigo">
                <table>
                    <tbody>
                        <tr class="cabecalhoEditorCodigo"><td class="linhaEditorCodigo">Python</td></tr>
                        <tr>
                            <td class="umtab">
                                lista1 <span class="rosacodigo">=</span> ["maçã", "banana", "cereja", "laranja", "kiwi", "melão", "manga"]<br>
                                <span class="verdecodigo">print</span>(lista1[2:5]) <span class="cinzacodigo"># ['cereja', 'laranja', 'kiwi']</span>
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <p>
                Para verificar se um item está presente em uma lista, use a palavra-chave in:
            </p>

            <div class="tabelaEditorCodigo">
                <table>
                    <tbody>
                        <tr class="cabecalhoEditorCodigo"><td class="linhaEditorCodigo">Python</td></tr>
                        <tr>
                            <td class="umtab">
                                lista1 <span class="rosacodigo">=</span> ["maçã", "banana", "cereja"]<br>
                                <span class="azulcodigo">if</span> "maçã" <span class="azulcodigo">in</span> lista1:<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;<span class="verdecodigo">print</span>("Sim, 'maçã' é uma fruta da lista")
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <p>
                Para alterar o valor de um item específico, consulte o índice correspondente:
            </p>

            <div class="tabelaEditorCodigo">
                <table>
                    <tbody>
                        <tr class="cabecalhoEditorCodigo"><td class="linhaEditorCodigo">Python</td></tr>
                        <tr>
                            <td class="umtab">
                                lista1 <span class="rosacodigo">=</span> ["maçã", "banana", "cereja"]<br>
                                lista1[1] <span class="rosacodigo">=</span> "abacaxi"<br>
                                <span class="verdecodigo">print</span>(lista1) <span class="cinzacodigo"># ['maçã', 'abacaxi', 'cereja']</span>
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <p>
                Também é possível alterar múltiplos valores em um intervalo de índices:
            </p>

            <div class="tabelaEditorCodigo">
                <table>
                    <tbody>
                        <tr class="cabecalhoEditorCodigo"><td class="linhaEditorCodigo">Python</td></tr>
                        <tr>
                            <td class="umtab">
                                lista1 <span class="rosacodigo">=</span> ["maçã", "banana", "cereja", "laranja", "kiwi", "manga"]<br>
                                lista1[1:3] <span class="rosacodigo">=</span> ["abacaxi", "melancia"]<br>
                                <span class="verdecodigo">print</span>(lista1) <span class="cinzacodigo"># ['maçã', 'abacaxi', 'melancia', 'laranja', 'kiwi', 'manga']</span>
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <p>
                Python possui diversos métodos embutidos que podem ser usados em listas/matrizes, que veremos a seguir.
            </p>

            <div class="tabelaExplica">
                <table>
                    <tbody>
                        <tr>
                            <th>Método</th>
                            <th>Descrição</th>
                        </tr>
                        <tr>
                            <th>append()</th>
                            <td>Adiciona um elemento no final da lista</td>
                        </tr>
                        <tr>
                            <th>clear()</th>
                            <td>Remove todos os elementos da lista</td>
                        </tr>
                        <tr>
                            <th>copy()</th>
                            <td>Retorna uma cópia da lista</td>
                        </tr>
                        <tr>
                            <th>count()</th>
                            <td>Retorna o número de elementos com o valor especificado</td>
                        </tr>
                        <tr>
                            <th>extend()</th>
                            <td>Adiciona os elementos de uma lista (ou qualquer iterável), ao final da lista atual</td>
                        </tr>
                        <tr>
                            <th>index()</th>
                            <td>Retorna o índice do primeiro elemento com o valor especificado</td>
                        </tr>
                        <tr>
                            <th>insert()</th>
                            <td>Adiciona um elemento na posição especificada</td>
                        </tr>
                        <tr>
                            <th>pop()</th>
                            <td>Remove o elemento na posição especificada</td>
                        </tr>
                        <tr>
                            <th>remove()</th>
                            <td>Remove o primeiro item com o valor especificado</td>
                        </tr>
                        <tr>
                            <th>reverse()</th>
                            <td>Inverte a ordem da lista</td>
                        </tr>
                        <tr>
                            <th>sort()</th>
                            <td>Ordena os elementos da lista em ordem crescente (por padrão)</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <p>Você pode percorrer os itens da lista usando um loop for:</p>
            <div class="tabelaEditorCodigo">
            <table>
                <tbody>
                <tr class="cabecalhoEditorCodigo">
                    <td class="linhaEditorCodigo">Python</td>
                </tr>
                <tr>
                    <td class="umtab">
                    <span class="azulcodigo">lista1</span> <span class="rosacodigo">=</span> ["maçã", "banana", "laranja"]<br>
                    <span class="azulcodigo">for</span> x <span class="azulcodigo">in</span> lista1:<br>
                    &nbsp;&nbsp;<span class="verdecodigo">print</span>(x)
                    </td>
                </tr>
                </tbody>
            </table>
            </div>

            <p>Além disso, é possível percorrer os itens da lista consultando seu número de índice. Use as funções range() e len() para criar um iterável adequado.</p>
            <div class="tabelaEditorCodigo">
            <table>
                <tbody>
                <tr class="cabecalhoEditorCodigo">
                    <td class="linhaEditorCodigo">Python</td>
                </tr>
                <tr>
                    <td class="umtab">
                    <span class="azulcodigo">lista1</span> <span class="rosacodigo">=</span> ["maçã", "banana", "laranja"]<br>
                    <span class="azulcodigo">for</span> i <span class="azulcodigo">in</span> <span class="azulcodigo">range</span>(<span class="azulcodigo">len</span>(lista1)):<br>
                    &nbsp;&nbsp;<span class="verdecodigo">print</span>(lista1[i])
                    </td>
                </tr>
                </tbody>
            </table>
            </div>

            <p>Outra forma de percorrer a lista é usando um loop while. Use a função len() para determinar o comprimento da lista, então comece em 0 e faça um loop pelos itens da lista consultando seus índices. Lembre-se de aumentar o índice em 1 após cada iteração.</p>
            <div class="tabelaEditorCodigo">
            <table>
                <tbody>
                <tr class="cabecalhoEditorCodigo">
                    <td class="linhaEditorCodigo">Python</td>
                </tr>
                <tr>
                    <td class="umtab">
                    <span class="azulcodigo">lista1</span> <span class="rosacodigo">=</span> ["maçã", "banana", "laranja"]<br>
                    i <span class="rosacodigo">=</span> 0<br>
                    <span class="azulcodigo">while</span> i &lt; <span class="azulcodigo">len</span>(lista1)<br>
                    &nbsp;&nbsp;<span class="verdecodigo">print</span>(lista1[i])<br>
                    &nbsp;&nbsp;i <span class="rosacodigo">=</span> i + 1
                    </td>
                </tr>
                </tbody>
            </table>
            </div>
            
            <h4>Tuplas</h4>

            <p>Tuplas são usadas para <strong>armazenar vários itens em uma única variável</strong>. Tupla é um dos 4 tipos de dados internos do Python usados para <strong>armazenar coleções de dados</strong>, os outros 3 são List, Set e Dictionary, todos com qualidades e usos diferentes. Uma tupla é uma <strong>coleção ordenada e imutável</strong>.</p>

            <p>Os itens de tupla são <strong>indexados</strong>, o <strong>primeiro item possui índice [0]</strong>, o segundo item possui índice [1], e assim sucessivamente. Quando dizemos que as tuplas estão ordenadas, significa que os itens têm uma ordem definida, e <strong>essa ordem não será alterada</strong>.</p>

            <p class="destaqueVermelho">As tuplas são imutáveis, o que significa que não podemos alterar, adicionar ou remover itens após a criação da tupla. </p>

            <p>Como as tuplas são indexadas, elas <strong>podem ter itens com o mesmo valor</strong>, ou seja, tuplas permitem duplicatas:</p>

            <div class="tabelaEditorCodigo">
            <table>
                <tbody>
                <tr class="cabecalhoEditorCodigo">
                    <td class="linhaEditorCodigo">Python</td>
                </tr>
                <tr>
                    <td class="umtab">tupla1 <span class="rosacodigo">=</span> ("maça", "banana", "laranja","maça")</td>
                </tr>
                </tbody>
            </table>
            </div>

            <p>Para determinar quantos itens uma tupla possui, use a função <strong>len()</strong>:</p>
            <div class="tabelaEditorCodigo">
            <table>
                <tbody>
                <tr class="cabecalhoEditorCodigo">
                    <td class="linhaEditorCodigo">Python</td>
                </tr>
                <tr>
                    <td class="umtab"><span class="verdecodigo">print</span>(<span class="azulcodigo">len</span>(tupla1))</td>
                </tr>
                </tbody>
            </table>
            </div>

            <p>Os itens de tupla podem ser de <strong>qualquer tipo de dados:</strong></p>
            <div class="tabelaEditorCodigo">
            <table>
                <tbody>
                <tr class="cabecalhoEditorCodigo"><td class="linhaEditorCodigo">Python</td></tr>
                <tr>
                    <td class="umtab">
                    tupla1 <span class="rosacodigo">=</span> ("maça", "banana", "laranja") <span class="comentario">#tupla de strings</span><br>
                    tupla2 <span class="rosacodigo">=</span> (1, 5, 7, 9, 3) <span class="comentario">#tupla de inteiros</span><br>
                    tupla3 <span class="rosacodigo">=</span> (True, False, False) <span class="comentario">#tupla de booleanos</span><br>
                    tupla4 <span class="rosacodigo">=</span> ("abc", 34, True, 40, "masculino") <span class="comentario">#diversos tipos</span>
                    </td>
                </tr>
                </tbody>
            </table>
            </div>

            <p>Para acessar os itens da tupla, é possível consultar o número do índice, entre colchetes:</p>
            <div class="tabelaEditorCodigo">
            <table>
                <tbody>
                <tr class="cabecalhoEditorCodigo"><td class="linhaEditorCodigo">Python</td></tr>
                <tr>
                    <td class="umtab">
                    tupla1 <span class="rosacodigo">=</span> ("maça", "banana", "laranja")<br>
                    <span class="verdecodigo">print</span>(tupla1[1]) <span class="comentario">#imprime banana</span>
                    </td>
                </tr>
                </tbody>
            </table>
            </div>

            <p>Também é possível acessar tuplas com índice negativo:</p>
            <div class="tabelaEditorCodigo">
            <table>
                <tbody>
                <tr class="cabecalhoEditorCodigo"><td class="linhaEditorCodigo">Python</td></tr>
                <tr>
                    <td class="umtab">
                    tupla1 <span class="rosacodigo">=</span> ("maça", "banana", "laranja")<br>
                    <span class="verdecodigo">print</span>(tupla1[-1]) <span class="comentario">#imprime laranja</span>
                    </td>
                </tr>
                </tbody>
            </table>
            </div>

            <p>Tuplas são imutáveis, mas é possível excluí-las com a palavra-chave <strong>del</strong></p>
            <div class="tabelaEditorCodigo">
            <table>
                <tbody>
                <tr class="cabecalhoEditorCodigo"><td class="linhaEditorCodigo">Python</td></tr>
                <tr>
                    <td class="umtab">
                    tupla1 <span class="rosacodigo">=</span> ("maça", "banana", "laranja")<br>
                    <span class="azulcodigo">del</span> tupla1
                    </td>
                </tr>
                </tbody>
            </table>
            </div>

            <p>É possível percorrer os itens da tupla usando um loop <strong>for</strong>:</p>
            <div class="tabelaEditorCodigo">
            <table>
                <tbody>
                <tr class="cabecalhoEditorCodigo"><td class="linhaEditorCodigo">Python</td></tr>
                <tr>
                    <td class="umtab">
                    tupla1 <span class="rosacodigo">=</span> ("maçã", "banana", "laranja")<br>
                    <span class="azulcodigo">for</span> x <span class="azulcodigo">in</span> tupla1:<br>
                    &nbsp;&nbsp;<span class="verdecodigo">print</span>(x)
                    </td>
                </tr>
                </tbody>
            </table>
            </div>

            <p>Também é possível percorrer os itens da tupla com índices. Use as funções range()e len() para criar um iterável adequado.</p>
            <div class="tabelaEditorCodigo">
            <table>
                <tbody>
                <tr class="cabecalhoEditorCodigo"><td class="linhaEditorCodigo">Python</td></tr>
                <tr>
                    <td class="umtab">
                    tupla1 <span class="rosacodigo">=</span> ("maçã", "banana", "laranja")<br>
                    <span class="azulcodigo">for</span> i <span class="azulcodigo">in</span> <span class="azulcodigo">range</span>(<span class="azulcodigo">len</span>(tupla1)):<br>
                    &nbsp;&nbsp;<span class="verdecodigo">print</span>(tupla1[i])
                    </td>
                </tr>
                </tbody>
            </table>
            </div>

            <p>Outra forma é com um loop <strong>while</strong>. Use a função <strong>len()</strong> para <strong>determinar o comprimento da tupla</strong>, então comece em 0 e <strong>faça um loop pelos itens da tupla consultando seus índices</strong>. Lembre-se, sempre, de aumentar o índice em 1 após cada iteração.</p>
            <div class="tabelaEditorCodigo">
            <table>
                <tbody>
                <tr class="cabecalhoEditorCodigo"><td class="linhaEditorCodigo">Python</td></tr>
                <tr>
                    <td class="umtab">
                    tupla1 <span class="rosacodigo">=</span> ("maçã", "banana", "laranja")<br>
                    i <span class="rosacodigo">=</span> 0<br>
                    <span class="azulcodigo">while</span> i &lt; <span class="azulcodigo">len</span>(tupla1):<br>
                    &nbsp;&nbsp;<span class="verdecodigo">print</span>(tupla1[i])<br>
                    &nbsp;&nbsp;i <span class="rosacodigo">=</span> i + 1
                    </td>
                </tr>
                </tbody>
            </table>
            </div>

            <p>Tuplas podem ser concatenadas com <strong>+</strong>:</p>
            <div class="tabelaEditorCodigo">
            <table>
                <tbody>
                <tr class="cabecalhoEditorCodigo"><td class="linhaEditorCodigo">Python</td></tr>
                <tr>
                    <td class="umtab">
                    tupla1 <span class="rosacodigo">=</span> ("a", "b", "c")<br>
                    tupla2 <span class="rosacodigo">=</span> (1, 2, 3)<br>
                    tupla3 <span class="rosacodigo">=</span> tupla1 + tupla2<br>
                    <span class="verdecodigo">print</span>(tupla3)
                    </td>
                </tr>
                </tbody>
            </table>
            </div>

            <p>Python possui dois métodos integrados que você pode usar em tuplas.</p>

            <div class="tabelaExplica">
                <table>
                    <tbody>
                        <tr>
                            <th>Método</th>
                            <th>Descrição</th>
                        </tr>
                        <tr>
                            <th>count()</th>
                            <td>Retorna o número de vezes que um valor especificado ocorre em uma tupla</td>
                        </tr>
                        <tr>
                            <th>index()</th>
                            <td>Procura na tupla um valor especificado e retorna a posição de onde foi encontrado</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <p>Também é possível multiplicar os itens da tupla usando <strong>*</strong>:</p>
            <div class="tabelaEditorCodigo">
            <table>
                <tbody>
                <tr class="cabecalhoEditorCodigo"><td class="linhaEditorCodigo">Python</td></tr>
                <tr>
                    <td class="umtab">
                    frutas <span class="rosacodigo">=</span> ("maçã", "banana", "laranja")<br>
                    tupla1 <span class="rosacodigo">=</span> frutas * 2<br>
                    <span class="verdecodigo">print</span>(tupla1)<br>
                    <span class="comentario"># imprime ('maçã', 'banana', 'laranja', 'maçã', 'banana', 'laranja')</span>
                    </td>
                </tr>
                </tbody>
            </table>
            </div>

            <h4>Conjuntos (Sets)</h4>

            <p>Conjuntos, também conhecidos como <em><strong>SETs</strong></em>, são usados para armazenar vários itens em uma única variável. 
            Um <strong>conjunto</strong> é uma <strong>coleção não ordenada, mutável e não indexada</strong>. São escritos com chaves:</p>

            <div class="tabelaEditorCodigo">
                <table>
                    <tbody>
                        <tr class="cabecalhoEditorCodigo"><td class="linhaEditorCodigo">Python</td></tr>
                        <tr>
                            <td class="umtab"><span class="azulcodigo">conjunto1</span> <span class="rosacodigo">=</span> {<span class="amarelocodigo">"maça"</span>, <span class="amarelocodigo">"banana"</span>, <span class="amarelocodigo">"cereja"</span>}</td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="verdecodigo">print</span>(conjunto1)</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <p>Não ordenado significa que os <strong>itens em um conjunto não têm uma ordem definida</strong>. 
            Os itens do conjunto podem aparecer em uma ordem diferente toda vez que você os usa e <strong>não podem ser referenciados por índice ou chave</strong>.</p>

            <p>Um conjunto (set) é <strong>mutável</strong>, ou seja, <strong>é possível adicionar e remover elementos após sua criação</strong>, <strong>mas os elementos devem ser imutáveis</strong>. 
            Além disso, <strong>conjuntos não aceitam itens duplicados</strong>.É possível determinar quantos itens um conjunto possui usando a função <strong>len()</strong>. 

            <p><strong>Não é possível</strong> acessar itens em um conjunto fazendo referência a <strong>um índice ou a uma chave</strong>. Mas você pode <strong>percorrer os itens</strong> do conjunto <strong>usando um loop for</strong> ou perguntar se um valor especificado está presente em um conjunto, usando a palavra-chave <strong>in</strong>.</p>

            <div class="tabelaEditorCodigo">
                <table>
                    <tbody>
                        <tr class="cabecalhoEditorCodigo"><td class="linhaEditorCodigo">Python</td></tr>
                        <tr>
                            <td class="umtab"><span class="azulcodigo">thisset</span> <span class="rosacodigo">=</span> {<span class="amarelocodigo">"maça"</span>, <span class="amarelocodigo">"banana"</span>, <span class="amarelocodigo">"cereja"</span>}</td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="roxocodigo">for</span> x <span class="roxocodigo">in</span> thisset:</td>
                        </tr>
                        <tr>
                            <td class="doistab"><span class="verdecodigo">print</span>(x)</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <p><strong>Não é possível alterar itens</strong> depois que um conjunto é criado, mas é possível <strong>adicionar novos itens</strong> com o método <strong>add()</strong>:</p>

            <div class="tabelaEditorCodigo">
                <table>
                    <tbody>
                        <tr class="cabecalhoEditorCodigo"><td class="linhaEditorCodigo">Python</td></tr>
                        <tr>
                            <td class="umtab"><span class="azulcodigo">thisset</span> <span class="rosacodigo">=</span> {<span class="amarelocodigo">"maça"</span>, <span class="amarelocodigo">"banana"</span>, <span class="amarelocodigo">"cereja"</span>}</td>
                        </tr>
                        <tr>
                            <td class="umtab">thisset.add(<span class="amarelocodigo">"laranja"</span>)</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <p>Para adicionar <strong>itens de outro conjunto ao conjunto atual</strong>, use o método <strong>update()</strong>:</p>

            <div class="tabelaEditorCodigo">
                <table>
                    <tbody>
                        <tr class="cabecalhoEditorCodigo"><td class="linhaEditorCodigo">Python</td></tr>
                        <tr>
                            <td class="umtab"><span class="azulcodigo">thisset</span> <span class="rosacodigo">=</span> {<span class="amarelocodigo">"maça"</span>, <span class="amarelocodigo">"banana"</span>, <span class="amarelocodigo">"cereja"</span>}</td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="azulcodigo">tropical</span> <span class="rosacodigo">=</span> {<span class="amarelocodigo">"pinemaça"</span>, <span class="amarelocodigo">"mango"</span>, <span class="amarelocodigo">"papaya"</span>}</td>
                        </tr>
                        <tr>
                            <td class="umtab">thisset.update(tropical)</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <p>O objeto no método <strong>update()</strong> não precisa ser um conjunto, <strong>pode ser qualquer objeto iterável (tupla, lista, dicionário, etc.)</strong>:</p>

            <div class="tabelaEditorCodigo">
                <table>
                    <tbody>
                        <tr class="cabecalhoEditorCodigo"><td class="linhaEditorCodigo">Python</td></tr>
                        <tr>
                            <td class="umtab"><span class="azulcodigo">thisset</span> <span class="rosacodigo">=</span> {<span class="amarelocodigo">"maça"</span>, <span class="amarelocodigo">"banana"</span>, <span class="amarelocodigo">"cereja"</span>}</td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="azulcodigo">mylist</span> <span class="rosacodigo">=</span> [<span class="amarelocodigo">"kiwi"</span>, <span class="amarelocodigo">"laranja"</span>]</td>
                        </tr>
                        <tr>
                            <td class="umtab">thisset.update(mylist)</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <p>Para remover itens, use <strong>remove() ou discard()</strong>. 
            A diferença é que <strong>remove() gera erro se o item não existir</strong>, enquanto <strong>discard() não gera erro</strong>:</p>

            <div class="tabelaEditorCodigo">
                <table>
                    <tbody>
                        <tr class="cabecalhoEditorCodigo"><td class="linhaEditorCodigo">Python</td></tr>
                        <tr>
                            <td class="umtab"><span class="azulcodigo">thisset</span> <span class="rosacodigo">=</span> {<span class="amarelocodigo">"maça"</span>, <span class="amarelocodigo">"banana"</span>, <span class="amarelocodigo">"cereja"</span>}</td>
                        </tr>
                        <tr>
                            <td class="umtab">thisset.remove(<span class="amarelocodigo">"banana"</span>)</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <p>Além de <strong>remove()</strong> e <strong>discard()</strong>, temos o método <strong>pop()</strong> (remove um item aleatório), 
            o método <strong>clear() (esvazia o conjunto)</strong>, e a palavra-chave <strong>del (apaga o conjunto por completo)</strong>.</p>

            <p>Também é possível unir conjuntos. O método <strong>union() cria um novo conjunto</strong> com todos os itens, 
            e o método <strong>update() adiciona os itens de um conjunto em outro</strong>. Ambos excluirão quaisquer itens duplicados.</p>

            <div class="tabelaEditorCodigo">
                <table>
                    <tbody>
                        <tr class="cabecalhoEditorCodigo"><td class="linhaEditorCodigo">Python</td></tr>
                        <tr>
                            <td class="umtab"><span class="azulcodigo">set1</span> <span class="rosacodigo">=</span> {<span class="amarelocodigo">"a"</span>, <span class="amarelocodigo">"b"</span>, <span class="amarelocodigo">"c"</span>}</td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="azulcodigo">set2</span> <span class="rosacodigo">=</span> {1, 2, 3}</td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="azulcodigo">set3</span> <span class="rosacodigo">=</span> set1.union(set2)</td>
                        </tr>
                        <tr>
                            <td class="umtab">set1.update(set2)</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <p>Abaixo é apresentada a tabela contendo o conjunto de métodos integrados que você pode usar em conjuntos.</p>

            <div class="tabelaExplica">
                <table>
                    <tr><th>Método</th><th>Descrição</th></tr>
                    <tr><td>add()</td><td>Adiciona um elemento ao conjunto</td></tr>
                    <tr><td>clear()</td><td>Remove todos os elementos do conjunto</td></tr>
                    <tr><td>copy()</td><td>Retorna uma cópia do conjunto</td></tr>
                    <tr><td>difference()</td><td>Retorna um conjunto contendo a diferença entre dois ou mais conjuntos</td></tr>
                    <tr><td>difference_update()</td><td>Remove os itens neste conjunto que também estão incluídos em outro conjunto especificado</td></tr>
                    <tr><td>discard()</td><td>Remove o item especificado</td></tr>
                    <tr><td>intersection()</td><td>Retorna um conjunto, que é a interseção de dois outros conjuntos</td></tr>
                    <tr><td>intersection_update()</td><td>Remove os itens neste conjunto que não estão presentes em outros conjuntos especificados</td></tr>
                    <tr><td>isdisjoint()</td><td>Retorna se dois conjuntos têm uma interseção ou não</td></tr>
                    <tr><td>issubset()</td><td>Retorna se outro conjunto contém este conjunto ou não</td></tr>
                    <tr><td>issuperset()</td><td>Retorna se este conjunto contém outro conjunto ou não</td></tr>
                    <tr><td>pop()</td><td>Remove um elemento do conjunto</td></tr>
                    <tr><td>remove()</td><td>Remove o elemento especificado (gera erro se não existir)</td></tr>
                    <tr><td>symmetric_difference()</td><td>Retorna um conjunto com as diferenças simétricas de dois conjuntos</td></tr>
                    <tr><td>symmetric_difference_update()</td><td>Insere as diferenças simétricas deste conjunto e de outro</td></tr>
                    <tr><td>union()</td><td>Retorna um conjunto contendo a união de conjuntos</td></tr>
                    <tr><td>update()</td><td>Atualize o conjunto com a união deste conjunto e outros</td></tr>
                </table>
            </div>

            <h4>Dicionários</h4>

            <p>Os <strong>dicionários</strong> em Python são usados para armazenar valores de dados em pares <strong>chave:valor</strong>. 
            Um dicionário é uma <strong>coleção ordenada</strong> - a partir do Python 3.7, <strong>mutável</strong> e que <strong>não permite duplicatas</strong>. Os dicionários possuem <strong>chaves e valores</strong>:</p>

            <div class="tabelaEditorCodigo">
                <table>
                    <tbody>
                        <tr class="cabecalhoEditorCodigo">
                            <td class="linhaEditorCodigo">Python</td>
                        </tr>
                        <tr>
                            <td class="umtab"><span class="azulcodigo">carros</span> = {<span class="laranjacodigo">"marca"</span>: <span class="laranjacodigo">"Toyota"</span>, 
                    <span class="laranjacodigo">"modelo"</span>: <span class="laranjacodigo">"Corolla Cross"</span>, 
                    <span class="laranjacodigo">"ano"</span>: <span class="laranjacodigo">2022</span>}

                    <span class="verdecodigo">print</span>(carros[<span class="laranjacodigo">"modelo"</span>])
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <p>Para referenciar um item do dicionário, usamos o <strong>nome da chave</strong>. 
            No exemplo acima, <code>print(carros["modelo"])</code> retorna <em>Corolla Cross</em>.</p>

            <p>Quando dizemos que os dicionários estão <strong>ordenados</strong>, significa que os <strong>itens têm uma ordem definida</strong>, <strong>e essa ordem não será alterada</strong>.</p>
            <p>Por outro lado, <strong><strong>não ordenado</strong></strong> significa que <strong>não podemos fazer referência a um item usando índice numérico</strong>, apenas pelas chaves.</p>
            <p>Os dicionários são <strong>mutáveis</strong>, ou seja, podemos alterar, adicionar ou remover itens após a criação.</p>
            <p>Além disso, <strong>não podem conter duas chaves iguais</strong>.</p>


            <p><strong>Métodos mais usados em dicionários:</strong></p>

            <div class="tabelaExplica">
                <table>
                    <tbody>
                        <tr>
                            <th>Método</th>
                            <th>Descrição</th>
                        </tr>
                        <tr>
                            <td>clear()</td>
                            <td>Remove todos os elementos do dicionário</td>
                        </tr>
                        <tr>
                            <td>copy()</td>
                            <td>Retorna uma cópia do dicionário</td>
                        </tr>
                        <tr>
                            <td>fromkeys()</td>
                            <td>Retorna um dicionário com as chaves e o valor especificados</td>
                        </tr>
                        <tr>
                            <td>get()</td>
                            <td>Retorna o valor da chave especificada</td>
                        </tr>
                        <tr>
                            <td>items()</td>
                            <td>Retorna uma lista contendo uma tupla para cada par de valores-chave</td>
                        </tr>
                        <tr>
                            <td>keys()</td>
                            <td>Retorna uma lista contendo as chaves do dicionário</td>
                        </tr>
                        <tr>
                            <td>pop()</td>
                            <td>Remove o elemento com a chave especificada</td>
                        </tr>
                        <tr>
                            <td>popitem()</td>
                            <td>Remove o último par de valores-chave inserido</td>
                        </tr>
                        <tr>
                            <td>setdefault()</td>
                            <td>Retorna o valor da chave especificada. Se a chave não existir: insira a chave, com o valor especificado</td>
                        </tr>
                        <tr>
                            <td>update()</td>
                            <td>Atualiza o dicionário com os pares de valores-chave especificados</td>
                        </tr>
                        <tr>
                            <td>values()</td>
                            <td>Retorna uma lista de todos os valores no dicionário</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <h4>Comparação - Listas, Tuplas, Set e Dicionários</h4>

            <p><strong>Comparação entre estruturas:</strong></p>

            <div class="tabelaExplica">
                <table>
                    <tbody>
                        <tr>
                            <th>Critério</th>
                            <th>List</th>
                            <th>Tuple</th>
                            <th>Set</th>
                            <th>Dictionary</th>
                        </tr>
                        <tr>
                            <td>Ordenação</td>
                            <td>Ordenada</td>
                            <td>Ordenada</td>
                            <td>Não ordenada</td>
                            <td>Não ordenada</td>
                        </tr>
                        <tr>
                            <td>Modificação</td>
                            <td>Mutável</td>
                            <td>Imutável</td>
                            <td>Mutável</td>
                            <td>Mutável</td>
                        </tr>
                        <tr>
                            <td>Duplicatas</td>
                            <td>Permite</td>
                            <td>Permite</td>
                            <td>Não permite</td>
                            <td>Não permite</td>
                        </tr>
                        <tr>
                            <td>Indexação</td>
                            <td>Por inteiro</td>
                            <td>Por inteiro</td>
                            <td>Não indexada</td>
                            <td>Por string</td>
                        </tr>
                        <tr>
                            <td>Delimitador</td>
                            <td>Entre colchetes[ ]</td>
                            <td>Entre parênteses ( )</td>
                            <td>Entre chaves { }</td>
                            <td>Entre chaves { }</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <h3>Estruturas de Controle</h3>

            <h4>Condições</h4>
            <div class="tabelaEditorCodigo">
                <table>
                <tbody>
                    <tr class="cabecalhoEditorCodigo">
                    <td class="linhaEditorCodigo">Python</td>
                    </tr>
                    <tr>
                    <td class="umtab">idade <span class="rosacodigo">=</span> <span class="roxocodigo">20</span></td>
                    </tr>
                    <tr>
                    <td class="umtab"><span class="amarelocodigo">if</span> idade <span class="rosacodigo">&#62;=</span> <span class="roxocodigo">18</span><span class="rosacodigo">:</span></td>
                    </tr>
                    <tr>
                    <td class="doistab"><span class="verdecodigo">print</span>(<span class="verdelevecodigo">"Maior de idade"</span>)</td>
                    </tr>
                    <tr>
                    <td class="umtab"><span class="amarelocodigo">else:</span></td>
                    </tr>
                    <tr>
                    <td class="doistab"><span class="verdecodigo">print</span>(<span class="verdelevecodigo">"Menor de idade"</span>)</td>
                    </tr>
                </tbody>
                </table>
            </div>

            <h4>Laços</h4>
            <div class="tabelaEditorCodigo">
                <table>
                <tbody>
                    <tr class="cabecalhoEditorCodigo">
                    <td class="linhaEditorCodigo">Python</td>
                    </tr>
                    <tr>
                    <td class="umtab"><span class="amarelocodigo">for</span> i <span class="amarelocodigo">in</span> <span class="verdecodigo">range</span>(<span class="roxocodigo">3</span>)<span class="rosacodigo">:</span></td>
                    </tr>
                    <tr>
                    <td class="doistab"><span class="verdecodigo">print</span>(i)</td>
                    </tr>
                    <tr>
                    <td class="umtab"></td>
                    </tr>
                    <tr>
                    <td class="umtab">j <span class="rosacodigo">=</span> <span class="roxocodigo">0</span></td>
                    </tr>
                    <tr>
                    <td class="umtab"><span class="amarelocodigo">while</span> j <span class="rosacodigo">&#60;</span> <span class="roxocodigo">3</span><span class="rosacodigo">:</span></td>
                    </tr>
                    <tr>
                    <td class="doistab"><span class="verdecodigo">print</span>(j)</td>
                    </tr>
                    <tr>
                    <td class="doistab">j <span class="rosacodigo">+=</span> <span class="roxocodigo">1</span></td>
                    </tr>
                </tbody>
                </table>
            </div>

            <h3>Funções</h3>
            <div class="tabelaEditorCodigo">
                <table>
                <tbody>
                    <tr class="cabecalhoEditorCodigo">
                    <td class="linhaEditorCodigo">Python</td>
                    </tr>
                    <tr>
                    <td class="umtab"><span class="amarelocodigo">def</span> saudacao(nome)<span class="rosacodigo">:</span></td>
                    </tr>
                    <tr>
                    <td class="doistab"><span class="amarelocodigo">return</span> <span class="verdelevecodigo">f"Olá, {nome}!"</span></td>
                    </tr>
                </tbody>
                </table>
            </div>

            <h4>Lambda (funções anônimas)</h4>
            <div class="tabelaEditorCodigo">
                <table>
                <tbody>
                    <tr class="cabecalhoEditorCodigo">
                    <td class="linhaEditorCodigo">Python</td>
                    </tr>
                    <tr>
                    <td class="umtab">dobro <span class="rosacodigo">=</span> <span class="amarelocodigo">lambda</span> x<span class="rosacodigo">:</span> x <span class="rosacodigo">*</span> <span class="roxocodigo">2</span></td>
                    </tr>
                    <tr>
                    <td class="umtab"><span class="verdecodigo">print</span>(dobro(<span class="roxocodigo">5</span>)) <span class="verdecodigo"># 10</span></td>
                    </tr>
                </tbody>
                </table>
            </div>

            <h3>Classes e Objetos</h3>
            <div class="tabelaEditorCodigo">
                <table>
                <tbody>
                    <tr class="cabecalhoEditorCodigo">
                    <td class="linhaEditorCodigo">Python</td>
                    </tr>
                    <tr>
                    <td class="umtab"><span class="amarelocodigo">class</span> Pessoa<span class="rosacodigo">:</span></td>
                    </tr>
                    <tr>
                    <td class="doistab"><span class="amarelocodigo">def</span> __init__(self, nome, idade)<span class="rosacodigo">:</span></td>
                    </tr>
                    <tr>
                    <td class="tresstab">self.nome <span class="rosacodigo">=</span> nome</td>
                    </tr>
                    <tr>
                    <td class="tresstab">self.idade <span class="rosacodigo">=</span> idade</td>
                    </tr>
                    <tr>
                    <td class="doistab"><span class="amarelocodigo">def</span> apresentar(self)<span class="rosacodigo">:</span></td>
                    </tr>
                    <tr>
                    <td class="tresstab"><span class="amarelocodigo">return</span> <span class="verdelevecodigo">f"Meu nome é {self.nome} e tenho {self.idade} anos."</span></td>
                    </tr>
                    <tr>
                    <td class="umtab">p <span class="rosacodigo">=</span> Pessoa(<span class="verdelevecodigo">"Carlos"</span>, <span class="roxocodigo">30</span>)</td>
                    </tr>
                    <tr>
                    <td class="umtab"><span class="verdecodigo">print</span>(p.apresentar())</td>
                    </tr>
                </tbody>
                </table>
            </div>

            <h3>Automação com Python</h3>
            <ul>
                <li><strong>PyAutoGUI</strong> → automação de mouse e teclado</li>
                <li><strong>Selenium</strong> → automação de navegadores</li>
                <li><strong>OpenPyXL / XlsxWriter</strong> → planilhas Excel</li>
                <li><strong>PDFMiner / ReportLab</strong> → manipulação de PDFs</li>
                <li><strong>Robot Framework / TagUI</strong> → automação de processos (RPA)</li>
            </ul>

            </div>

        </section>

        <section>

            <!-- AULA EXTRA - NÚMEROS BINÁRIOS-->
    
            <h2>Números Binários</h2>
            <p>
                O sistema binário é um sistema de numeração posicional que utiliza apenas dois dígitos: 
                <strong>0</strong> e <strong>1</strong>. Cada posição representa uma potência de 2, assim como no sistema decimal cada posição representa uma potência de 10.
            </p>

            <h3>Potências de 2 (Correspondência das Casas)</h3>
            <p>
                Da direita para a esquerda, cada casa em binário vale o dobro da anterior:
            </p>
            <ul>
                <li>1</li>
                <li>2</li>
                <li>4</li>
                <li>8</li>
                <li>16</li>
                <li>32</li>
                <li>64</li>
                <li>128</li>
                <li>256</li>
                <li>512</li>
                <li>1024 ...</li>
            </ul>

            <h3>Tabela de Conversão</h3>
            <table border="1" cellpadding="6" cellspacing="0">
                <thead>
                <tr>
                    <th>Decimal</th>
                    <th>Binário</th>
                    <th>Hexadecimal</th>
                </tr>
                </thead>
                <tbody>
                <tr><td>0</td><td>0000</td><td>0</td></tr>
                <tr><td>1</td><td>0001</td><td>1</td></tr>
                <tr><td>2</td><td>0010</td><td>2</td></tr>
                <tr><td>3</td><td>0011</td><td>3</td></tr>
                <tr><td>4</td><td>0100</td><td>4</td></tr>
                <tr><td>5</td><td>0101</td><td>5</td></tr>
                <tr><td>6</td><td>0110</td><td>6</td></tr>
                <tr><td>7</td><td>0111</td><td>7</td></tr>
                <tr><td>8</td><td>1000</td><td>8</td></tr>
                <tr><td>9</td><td>1001</td><td>9</td></tr>
                <tr><td>10</td><td>1010</td><td>A</td></tr>
                <tr><td>11</td><td>1011</td><td>B</td></tr>
                <tr><td>12</td><td>1100</td><td>C</td></tr>
                <tr><td>13</td><td>1101</td><td>D</td></tr>
                <tr><td>14</td><td>1110</td><td>E</td></tr>
                <tr><td>15</td><td>1111</td><td>F</td></tr>
                </tbody>
            </table>

            <h2>Soma e Subtração em Binário</h2>

            <h3>Soma</h3>
            <p>
                A soma em binário segue quatro regras simples:
            </p>
            <ul>
                <li>0 + 0 = 0</li>
                <li>0 + 1 = 1</li>
                <li>1 + 0 = 1</li>
                <li>1 + 1 = 10 (vai 1 para a próxima casa)</li>
            </ul>
            <p><strong>Exemplo:</strong></p>
            <pre style="text-align: left;">
   1011   (11 em decimal)
+  0110   (6 em decimal)
   -----
   10001   (17 em decimal)
            </pre>

            <h3>Subtração</h3>
            <p>
                A subtração em binário também tem quatro regras:
            </p>
            <ul>
                <li>0 - 0 = 0</li>
                <li>1 - 0 = 1</li>
                <li>1 - 1 = 0</li>
                <li>0 - 1 = 1 (com empréstimo da casa seguinte)</li>
            </ul>
            <p><strong>Exemplo:</strong></p>
            <pre style="text-align: left;">
   1011   (11 em decimal)
-  0110   (6 em decimal)
   -----
   0101   (5 em decimal)
            </pre>

        </section>

        <section class="campoQuestoes">
            <h2>Questões de Desenvolvimento de Software</h1>
            <div id="questoes"></div>
        </section>

    </main>
    <footer>
        <p>&copy; 2025 - Lulubas</p>
    </footer>
  
    <script src="../js/questoes.js"></script>
    <script>
      carregarQuestoes('desenvolvimentoDeSoftware', 15);
    </script>
</body>
</html>